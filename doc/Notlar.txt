15.11.2022

Java Eğitimi

Java Ders programı
Salı - Perşembe
Saat: 19:00 - 22:00


github'ta ders notları yedeklenecek.


1- Java Genel giriş 
2- Java özellikleri
3- Genel programlama pradigmaları
4- Sayı sistemleri
5- Bir java programı text sayafasına yazıp derleyip çalıştıracaz


HW1
-Assembly nedir neden var neden kullanımda hala?
-Unity ve Unreal Engine nedir ve diger oyun motorlarına inceleyelim.
-Interpereted programlama dili nedir?
-Garbage Collector Nedir nasıl çalışır?
-Memory leak
-Functional Programming, Prosedürel Programlama, Object Oriented Programming,
    Generic Programming, Imperative programming, Reflective programming, Concurrent
-Java programı derleme ve çalıştırma adımları
    JVM nedir 
    JRE nedir 
    JIT nedir 
    Byte code nedir 

    Bunlar hangi aşamalardan geçerken kullanılıyor?



ali olustur 
..
..

ali silindi progaramcı silmesin ben silerim G.C devereye giriyor 

C ve C++ da Garbage C. mekanizması yoktur. Programcı kendi siler kendi olsuturdugu nesneyi.


Programlama Dillerinin Sınıflandırılması

Programlama dillerini 3(üç) biçimde sınıflandırabiliriz:
1. Seviyelerine göre sınıflandırma

2. Kullanım alanlarına göre sınıflandırma

3. Programlama modeline göre sınıflandırma



Java programı derleme ve çalıştırma adımları





--------------------------------------------------------

HW2 

Stack ve Heap Nedir ?
Donanımsal karsılıkları?

Fonksiyonel programlama ile prosüdürel programlama arasındaki fark?
Imperative Programing?
Reflective programing?
Concurrent programing? 


--------------------------------------------------------
22.11.2022


HW3 
Github reopsu olusturmak kendi java norları için
Github'a kendini anlatan bilgi veren sade bir Overwiev olustur.
Google documentler den slaytları hazırlayalım

--------------------------------------------------------
/*******************************************************/
/*******************************************************/


Sayı Sistemleri 


2-8-10-16 temelde bu sayı sistemleri var 


2 lik sayı sistemi 

Neden kullanırız: tam sayı ve gerçek sayı sistemleri için kullanırız

4 66 76  -- 123,4 555.7


0101 1011 0001 1110 

ikilik  sayı sistemi işaretli ve işaretsiz olmak üzer iki gruba ayrılır 

işaretsiz - unsigned --> sayının pozitif oldgunu söyleer
işaretli -- signed ---> sayıların hem pozitif hem negatif olabiliceğini söyler 


Sistemlerin hemen hepsinde 

8 bitlik alana byte denilmektedir.

bit bit bit bit bit bit bit  bit
1   0   1    0   1   1   0   0  === byte 

bit = binary digit 
Byte = 8bit

Sistem programlamada daha küöçük birimler var 

4 bit = Nibble = yarım byte
8 bit = byte 
2 byte = word
4 byte = double word


Sayı sistemlerinde bazı işlemler

2'ye tümleyeni bulma konusu için pratik kurallar 

	0101  0100
	1010	 1100

sagdan baslayarak ilk 1 bitini gorene kadar 
bitlerin aynısını yazıyoruz
geri kalan kısmı ters ceviriyoruz
	

	0001  1000
     1110  1000    

---------------------
işaretli 2 lik sistem

sign bit --> sayının işaretni belirler
0 --> pozitif sayı
1 --> negatif sayı


işaretli sayı sistemlerinde 
Sistemlerin hemen hepsi negatif sayıyı gösterimi için
Sayının 2'ye tümleyini aritmatigi kullanır

aynı sayıınn pozitif ve negatif degerleri
sayının 2 ye tümlenyenleri

45
-45 gibi 

1110 1001 = -23
2^0 * 1 + 2^1 * 0 + 2^2 * 0 + 2^3 * 1 + 2^4 * 0 + 2^5 * 1 + + 2^6 * 1 + 2^7 * 1
0001 0111 = 23


Soru :  bir byte lık alanda -52 sayısını ifade edermisin

önce 52 degerinin bitlerini buluruz sonrada 2'ye tümelyeni buluruz. Eksili sayının 2 bitlik ifadesini 

0011 0100 = 52
1100 1100 = -52


---------------------------------------------
temel byte alanlarında yazılabilecek en buyuk ve en kucuk degerler 

unsigned sistemde

0  - 255
0  - 65535
0  - .....


signed sistemlerde

0111 1111 -- > 127 en buyuk tam sayı degeri 
1000 0001 ---> -127 - 1 = 128 en kucuk tam sayı degeri elde edilir 
1000 0000 --> -128


-128 127
-32768 - 32767
-2147483648  - 2147483647 

--------------------------------------------------------------

Soru: İşaretli 2 lik sayı sisteminde butun bitleri 1 olan sayı nedir

1111 1111 = -128 + 127 = -1
0000 0001 = 1 


--------------------------------------------------------------

16 LIK sayı sistemi 

hexadecimal sistem 
hex system denir 

16 tane sembol var

0123456789ABCDEF


Neden hex sistemi bizi ilgilendirir

aslında 2 lık sayı sisteminde 5 bitlik alanı tekbir yerde gosterebiliriz
ayrıca 16 lık sistem 2 nın katı olması işimizi kolaylaştırır



Soru: 2lık sayı sistemini 16 lık sayı sistemine cevirelim

1001  1110 1001 1111
  9    E    9    F

Soru:  1AC  onluk sayı sistemine donusturelim

1*16^2 + 10 * 16^1 + 12 * 16^0  = 256 + 160 + 12 = .....


-----------------------------------------------------------

Önce java gereksinimleri yuklenmeli işletim sistemine göre

Sonra 
Java ayarlarımızı consol'dan incelemeliyiz aynı versiyon olmalı  

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>java -version
java version "17.0.1" 2021-10-19 LTS
Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>javac -version
javac 17.0.1

-----------------------------------------------------------


Dil kavramı nedir?

Dil iletiişmde kullanılan semboller toplulugudur. Bir dilin kurallarına gramer denir.
Gramerin bir çok alanı vardır. En önemlileri "sentaks (syntax) " ve "semantik (semantic" dir.
Bir cümlenin olabilmesi için en azından sentaks ve semantiğe sahip olması gerekir.


Sentaks doğru yazma ve dogru dizilime ilişkin kurallardır.

		"I going to will fitness."

Java ornegi 

		System.out.println("Hello, World)";


Semantik: Dildeki dogru dizilmiş ögelerin ne anlama ifade ettiketlerine ilişkin kurallara da semantik denir.


Dipnot:
Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar bilimlerinde kullanılmak üzere tasarlanmış
dillere bilgisayar dilleri (computer langues) denir. Bir bilgisayar dilinde akış da varsa o zaman programalam dili
(programmin language) denir. Örnek: HTML, XML gibi bilgisayar dilleridir, programlama dili değildir.
C, C++, Java, C#, Swift..... gibi dillerde akış oldugunda programlama dilleridir. 


-----------------------------------------------------------

Hello World Program


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}


komutlar

-> javac orhn/App.java

-> java orhn.App


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

29.11.2022 Salı

Derleyici hata mesajları (diagnostics):

1. Gerçek hatalar (Error): Dilin sentaks ve semantik kurallarına uyulmamasından dolayı verilen mesajlardır.
	Bu durumda arakod(Byte code) üretilmez.

2. Uyarılar (warning): Byte kodun üretimine engel olmayan, olası programlama ve mantık hatalarının programcıya
	bildirilmesi içien verilen mesajlardır. Programcı bu uyarıları mutlaka dikkate almalıdır. Özel bir durum yoksa 
	uyarı mesajlarının oluşumuna yol açan kodlar düzeltilmelidir. Bazı duurmlarda derleyicinin uyarı mesajı verdiği ancak IDE'nin kullanıldıgı
	bir "static kod analizi araçları" konfigürasyonları gereği uyarı verebilirler. Şüphesiz bunlarda da dikkate alınmalıdır. Ancak bunların
	hepsi düzeltilmesi gerekmez.


3. Ölümcül hatalar (fatal errors): Derleme işleminin bile tamamlanmasını engelleyebilecek hatalardır. Bu durumda
	programcının yazdıgı kod açısından yapacak bir şeyi yoktur. Çünkü kod henüz derlememiştir. Programcının ölümcül hataya
	yol açan durumu ortadan kaldırmsı gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar ölümcül hatalara örnek gösterilebilir.


Programın çalışma zamanı sırasında oluşan hatalara genel olarak "exception" denir. Exception oluştugunda program sonlanır. 
Bu durum detayları "exception işlemleri(exception handling)" konusunda ele alınacaktır. Excepiton yerine "run time error" da kullanılabilrmektedir. 
"error" denildiginde "compile time error" anlaşılır.
  

-----------------------------------------------------------

Java'da yorum satırları (comment lines)


Not: Yorum satırları kodun okunabilirliğini/algılanabilirliğini bozacak şekilde koda eklenmemelidir
	Yorum satırı eklemenin de bir "convetion"'u olmadır.

package orhn;

class App{

    //Burası derleyici tarafından dikkate alınmaz.
    public static void main(String[] args) {
        System.out.println("Hello, World");    

        /*
            Burası da 
            derleyici
            tarafından 
            dikkate alınmaz 
         */
    }
}

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Atom (Token):
Bir programlama dilinde kendi başına anlamlı olan en küçük birime atom denir. Atomlar 6 gruba ayrılır.

1. Anahtar Sözcükler(keywords, reserved words): Dil için özel bir anlamı olan yeni dil tarafın bilinen ve 
	birçoğu doğrudan değişken ismi olarak kullanılamayan atomlardır. Örneğin: package, class, public, int, if, while vs.

2. Değişkenler (identifiers, variables): İsmini programcının belirlediği ve çeşitli kurallara göre isminin berlirlenebildiği atomlardır.
	Örneğin: App, String, System, orhn vs...

3. Operatörler (Operators): Bir işleme yol açan ve bu işlem sonucunda bir değer üreten atomlardır.
	Örneğin: a + b ifadesinde + bir operatordür

4. Sabitler (Literals, constants): Program içerisine doğrudan yazılan sayılara denir. Örneğin: a - 5 ifadesinde
	5 bir sabittir. 

5. String'ler (Strings, String Literals): iki tırnak (double quote) içersinde bulunan yazılar tırnaklarla birlikte string atomudur.
	Bu atoma string sabiti anlamında "string literal" da denir. Örneğin: "Hello, World"

6. Ayraçlar (delimiters, punctuators): Yukarıdaki gruplar dışında kaln tüm atomlara denir. Örneğin: {}, (), [] vs.

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Programı atomlarına parçalayalım


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}

package 		->  anahtar sözcük
orhn			-> değişken
class		-> anahtar sözcük
App			-> değişken
{}			-> ayraç
public		-> anahtar sözcük
static		-> anahtar sözcük
void 		-> anahtar sözcük
main			-> metod ismi değişken
()			-> ayıraç
String		-> değişken
[]			-> ayıraç 
args			-> değişken
{}			-> ayıraç
System		-> değişken
.			-> operator
out			-> değişken
println		-> değişken
()			-> metod çagırma operatoru
"Hello, World" -> String literals
;			-> Ayıraç


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Boşluk karakterleri (whitespaces): Klavyeden basılıgında bosluk algısı veren karakterlerdir.
	Klavyeden basılan bosluk karakterleri tipik olarak sunlardır: space, tab, enter 

-----------------------------------------------------------
-----------------------------------------------------------

	Java programlama dilinde kod yazım kuralları şunlardır:
	1. Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.
	2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.


-----------------------------------------------------------
-----------------------------------------------------------

Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.


package 



orhn;

class 







App{

    public static void main(String[


    ] 
    
    args) 
    
    {
        System.             out.            println("Hello, World");    

    }
}


-----------------------------------------------------------
-----------------------------------------------------------

2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		


package orhn;class App{public static void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.

package orhn;class App{publicstatic void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Not: Java'da derleme zamanı (compile time) ve çalışma zamanı (run time) denilen birbiriyle ilişkili
	ancak ayrı olan iki kavram vardır. Derleme zamanı derleme sürecinde yapılan işlemlere denir. 
	Çalışma zamanı programın çalışma sürecinde yapılan işlemlere denir.

-----------------------------------------------------------
-----------------------------------------------------------

Bildirim (declaration): Bildirim bir ismin derleyiciye tanıtılmasıdır. 
				    Derleyici bildirim ile o ismin ne anlama deldiğini anlar ve derleme işlemini ona göre yapar.


-----------------------------------------------------------
-----------------------------------------------------------

Bir java programı genel olarak paketlerden, paketler sınıflardan, sınıflarda metodlardan oluşur.

package <isim>;
Örnek:
package orhn;


class <isim> {


}

Örnek:

class Sample{
	//...
}


class Mample{
	//...
}





-----------------------------------------------------------
-----------------------------------------------------------
Metod bildirimlerin genel biçimi:

Java'da alt programlara metot (method) denir. Alt programın ne yapacağının yazılmasına "metot bildirimi (metot declaration)" denir.
Alt programın kodlarının çalıştırılmasına ise "metot çağırma (method call)" denir. Metot bildirimini genel biçimi:

[erişim belirleyici] [static/non-static] <geri dönüş değeri bilgisi> <metot ismi>([parametreler])
{
	//...
	//...

}

Açıklamalar:

-Erişim belirlemeleri şunlardan biri olabilir: public, protected, private, no-modifier(hiçbir şey yazılmaması)
	Metotların erişim berlirleyicileri konusuna gelene kadar tüm metodları public olarak bildirecez.

- Bir metot static veya non-static olabilir. static anahtar sözcüğü bildirimde yazılmasa metot non-static olur.
	non-static metotlara ilişkin konuya gelene kadar tüm metotları static olarak bildirecez.

- Metodun geri dönüş değeri bilgisi metot isminden önce yazılmalıdır. Metodun geri dönüş değerinin olmaması durumuda
	void yazılması demektir. Geri dönüş degerı kavramı da ileride ele alınacaktır.
- Metodun ismi bir değişken atomdur. Tğm değişken atomlarda oldugu gibi "değişken isimlendirme kuralları"na uygun 
	olarak isimlendirilmelidir.
-Metot bildirimlerinde motot isminden sonra parantezler içerisinde ismine "parametre (parameter)" deniken değişkenler bildirilebilir.
	Metot parametre değişkenleri ileride ele alınacaktır.
- Metot bildiriminde küme paratezleri arasında (metot gövdesi) metodun kodları yazılır 


static bir metodun çağrılmasının genel biçimi:

[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);


Bir program main metodunun çağrılmasıyla çalışmaya başlar. Programcının main metodu içerisinde çağırdığı motolar ve o metotların içerisinde çağrılan motolarla
akış devam eder. main metodu JVM tarafından çağrılır. Bu anlamda java programına verilen "byte code"'a ilişkin sınıfın main metoduna "giriş noktası (entry point)"
denir. Özel bazı özel durumlar dışında (bu özel durumlar vardı - extrem konularda karsımıza cıkar) main metodu sonlandıgında program sonlanır.
Bir metot çağrıldıgında akış metodun kodlarına dallanır (call) ve metodun kodları çalıştırılır. Şüphesiz metot içerisinde başka bir metot çağrılıyor olabilir.
Yine bu çapırma n0oktasında akıl metodun kodlarına dallanır. Metot çağrısı sonlandıgında akış metodun çağrıldıgı noktaya geri döner ve bir sonraki koddan akış 
çalışmaya devam eder.

Not: System.out.println("Hello World"); çağrısında System bir sınıf, out bir referans ve println de non-static bir metotdur.
	Bu kavramları ileride ele alacagız.

-----------------------------------------------------------
-----------------------------------------------------------

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        orhn.Sample.foo();
        orhn.Sample.bar();
        orhn.Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        orhn.Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------

Çağıran metodun (caller) ait oldugu sınıf ile çağıran metot (callee) ait oldugu sınıf 
aynı paket içerisindeyse çağırma sırasında paket ismi yazılmayabilir

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}
-----------------------------------------------------------
-----------------------------------------------------------
Çağıran metot ile çağrılan metot aynı sınfta ise bu durumda çağırma sırasında paket ismi yazılmamışsa sınıf 
ismide yazılmayabilir.

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
        foo();
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------
01.12.2022 Perşembe

IDE (Integrated Development Environment): Derleyiciler komut satırından çalıştırlabilen basit bir arayüze sahip
programlardır. Aslında teorik olarak java ile geliştirilecek bir uygulma içerisinde tüm java dosyları "notepad"
basit bir editor ile yazılıp, komut satırından derlenebilir. Fakat pratikte bu şekilde program yazman fazlaca 
zaman kaybettirir. Yazılım geliştirmeyi kolaylaştırmak için IDE debilen programlar kullanılır.
IDE'ler içerisinde editorler, test araçları, çeşitli kodlar üreten araçlar vs. bulunur. IDE bir derleyici değildir.
IDE derleme işlemi için derleyiciyi de çalıştırabilir. Uygulamayı çalıştırma işlemi için de yineJRE içerisindeki araçları 
kullanabilir. Java ile uygulma geliştirirken kullanılabilecek çeşitli IDE'ler bulunmaktadır. Bunlardan en yaygın 
kullanılanları "Eclipse" ve "IntelliJ IDEA" IDE'leridir. Önceleri Netbeans isminde bir IDE kullanılmaktaydı. 
Ancak Netbeans kullanımı oldukça azalmıştır.

-----------------------------------------------------------
-----------------------------------------------------------
Tür (type): Bir değişken için bellekte kaç byte ayrılacağını ve içerisindeki hangi
yöntemle veri tutulacagını belirten kavramdır.

Java'da türler genel olarak iki gruba ayrılabilir.
Temel türler (primitive/built*in/predefined types).
Programcının tanımladığı türler (user defined types).


Temel türler

Tür ismi			Uzunluğu(byte)
short				2
int					4
long				8
byte				1                           0 0 0 0  0 1 0 1  --> 5    ------- -128/127

float				4
double				8

char				2
boolean				-


-Java da türlerin uzunlukları boolean türü dışında sistemden sisteme değişmez.

-Tüm tam sayı türleri işaretlidir(signed)

-Tamsayı türleri (integer/integral types) için ikiye tümleme yöntemi kullanılır. Java'da işaretsiz tam sayı türleri yoktur.
Ancak java 8 ile birlikte belirli koşullar altında işaretsiz tamsayı işlemleri yapılabilmektedir.

-long türü en uzun tamsayı türüdür.

-Gerçek sayı(real/floating point types) için "IEEE 754 standardı" kullanılır. float ve double türleri sırasıyla
tek hassasiyetli (single precision) ve çift hassasiyetli (double precision) değerleri tutmaktadır. Bu türlerde bazı sayılar
tam olarak ifade edilemezler 0 sayıya yakın bir sayı ile ifade edilebilirler. Bir noktalı sayının ifade edilemeyip en yakın
sayı olarak ifade edilmesine yuvarlama hatası (rounding error) denir. Yuvarlama hataları değer ilk kez yerleştirilirken
de oluşabilir, bir işemin sonucunda da oluşabilir.


-Gerçek sayı türleri işaretli türlerdir.

-float türünün yuvarlama hatalarına karşı direnci zayıfır. Yanı yuvarlama hatası daha çok olmaktadır.

-Yuvarlama hataları parasal ve finansal uygulamarda hatalı değerlerin oluşmasına sebep olabilir. Sırf parasal
ve finansal uygulamalar için tasarlanmış özel türler (sınıflar) bulunur. Programcı böylesi uygulamalar için bu sınıfı
tercih eder. Ancak bu sınıflar yuvarlama hatası yapmamak için yüzlerce makine komutu ile bu işlemleri yapar.
Bu durumda programcı için parasal ve finansal uygulamalar gibi yuvarlama hatasının olmaması gerekn uygulamalar dışında double
yada durma göre float türü tercih edilmelidir.


-char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türünden 
değişken içerisinde bir karakterin UNICODE tablosu (ya da başka tablodaki) sıra numarası tutulur. UNICODE tablo
dünyadaki dillerde kullanılan hemen hemen tüm karakterleri ve bazı özel karakterleri ifade edebilme yeteneğine sahiptir.


-Yazılar içerisinde her bir karakter aslında bir sayı ile temsil edilir. Hangi karakterin hangi sayı ile ifade edildiği
karater tablosuna bağlıdır. ASCII tablosu 1 byte'lık yani 256 tane satırdan oluşur. UNICODE tablo 2 byte'lık
yani 65536 satırdan oluşan bir tablodur. Karakter tablolları bunlarla sınırlı değildir.


-boolean türünün alabileceği iki tane değer vardır: true, false. boolean türünün uzunluğu "Java Language Specification"'da
belirtilememiştir. Sistemden sisteme değişebilir. Ancak bu değişim programcı açısından problem oluşturmaz.

Not: int türüne "integer" demek yanlış bir terim kullanamk demektir. integer terimi tamsayılar için
kullanılan genel bir terimdir. Ayrıca "Integer" isimli bir sınıf da bulunmaktadır.

Not: Java'da en çok kullanılan tamsayı türü int türüdür. en çok kullanılan gerçek sayı türü de double türüdür.
Programcı öncelikle bu türleri tercih etmelidir. Eğer geçerli bir nedeni varsa diğer türleri kullanabilir.

-----------------------------------------------------------
-----------------------------------------------------------
HW3

IEEE 754 standardı nedir? 
Gerçek sayılar bu standarda göre nasıl ifade edilir?

1344.3454 ---> bunun sistemde nasıl ifade edildiği 
		   veya javada nasıl ifade edildiğini ögrenecez


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
Bir değişken kullanılmadan önce bildirilmelidir:
Değişken bildiriminin genel biçimi:
<tür> <değişken ismi>;

örnek:

int a;
float b;
boolean c;

-----------------------------------------------------------
-----------------------------------------------------------
Java'da 3 çeşit değişken vardır:
1. Yerel değişkenler (local variables)
2. Parametre değişkenleri (Parameter variables)
3. Sınıf veri elemanları (class member variables)


Değişkenler için temel kavramlar:
İsim(name): Belli kurallara göre yazılan karakterler topluluğudur.

Tür (type): Değişken için bellekte ne kadar yer ayrılacağı ve içerisinde değerlerin hangi yönteme göre tutulacağını belirtir.

Faaliyet alanı (scope): Bir değişken isminin derleyici tarafından görülebildiği kod aralığıdır. Derleme zamanına işilkindir.

Ömür (storage duration): Bir değişkenin bellekte kalma süresidir. Çalışma zamanına ilişkindir.

Temel bazı kavramlar:
Blok (block): Bir metot içerisinde { ile } arasında kalan kod bölümüdür. Metodun gövdesi de bir bloktur.

İlkdeğer verme (initialization): Bir değişkene bildirim noktasında verieln değer denir. 

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bir metot içerisinde istenildiği kadar ayrı veya iç içe bloklar olabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		{
			//...
			
			{
				//..
			}
		}
		
		{
			//...
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		{
			//...
			
			{
				double b;
				int c;
				//..
			}
		}
		
		{
			float d;
			//...
		}
	}
}

class Sample{
	public static void foo()
	{
		int x;
		
		//..
		{
			//..
			boolean f;
			//..
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı türden yerel değişkenler aralarında virgül konarak bildirilebilirler
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		double x, y, z;
	}
}

class Sample{
	public static void foo()
	{
		int x, y, z;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yerel değişkenlere ilkdeğer verme
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //ilk deger verme
		double pi = 3.14; //ilk degerveme sentaksı
	}
}

class Sample{
	public static void foo()
	{
		int x = 10, y = 30, z;
		
		z = 33;//initizlization değil.... 
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Yerel bir değikenin faaliyet alanı bildirildği yerden bildirilği bloğun sonuna kadardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x;
			
			x = 20;
			
			//..
			
			{
				x = 45;
			}
		}
		
		x = 15; //error
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		int a;
		double a; //error
		//..
	}
	
	public static void bar() 
	{
		int a;
		
		{
			double a; //error
			//..
			
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Farklı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçerlidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x = 10;
			//..
		}
		
		{
			int x = 20;
			//..
		}
		
		int x = 30;
		
		//..
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değer verilmemiş hiçbir değiken kullanılamaz. Yani içerisindeki değer işleme sokulamaz
 * Yerel değişkenlere değer verilmesi programcının sorumluluğundadır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		int b;
		
		b = a * 2; //error
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * print ve println metotları değişkenlerin içerisindeki değerleri ekrana basarlar
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		System.out.print(a); //ekrana yazdırır
		System.out.println(a); //--> print("") sonrada alt satıra geçiririm 
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimleri sayısal bir karakter ile başlamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int 1number; //error
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri herhangi bir uygun karakter ile başlatılıp istenildği kadar sayısal karater içerebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a12345 = 10; 
		
		System.out.println(a12345);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede UNICODE alfabetik karakterler kullanabiliir. Örneğin türkçe karakter geçerlidir ,
 * 
 * Not: Her ne kadar değişken isimlendirmede UNICODE karakterler kullanılabildse de programlamada yalnızca
 * İngilizce alfabetik 26 karakterin kullanılması iyi bir tekniktir. Biz de bu "convention"' a uygun kodlar yazacağız.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int öğrencisayısı = 10; 
		
		System.out.println(öğrencisayısı);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimlendirmede boşluk (whitespace) karakterleri geçersizdir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int number Of Students = 10; 
		
		System.out.println(number Of Students);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri büyük-küçük harf duyarlıdır (case-sensitive)
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int val, Val, VaL, VAL; //geçerli  
		
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede  _(underscore/ alttire) karakteri kullamabilir. Hatta değişken ismi _ karateri ile başalatılabilir.
 *
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int _11 = 20;
		int _val = 22;
		int number_of_students = 11;
		
		System.out.println(_11);
		System.out.println(_val);
		System.out.println(number_of_students);
		
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 9 ile birlikte alttire karaterinin tek başına değişken ismi olarak kullanıması geçersizdir. 
 * Java 8 ile birlikte "deprecated" olmuştur.
 * 
 * 
 * Not: Programlamda "artık kullanılması tavsiye edilmeyen" durumlar için "deprecated" terimi kullanılır.
 * Bu durum gerekçeleri farklı farklı olabilir. Programcı açısından genel olarak "deprecated" olan bir durum özel bir takım
 * nedenler yoksa tercih edilmemelidir.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int _ = 10; //error
		
		System.out.println(_);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değişken isimlendirme $ karakteri kullanılabilir. Hatta isimler $ karakteri ile başlayabilir. $ karakteri
 * tek başına değişken ismi olabilir. Ancak programcı açısından değişken isimlendire $ karakteri kullanılmamalıdır.
 * Derleyici ismini kendisinin belirlediği durumlarda isimlendirmede bu karateri kullanır. $ karakteri bu anlamada
 * programcı tarafından kullanılırsa iism çakışması olabilir. Zaten $ karaterinin varlık sabebi de bu
 * tip kod üretimlerinde kulllanılmasıdır.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int amountOf$s = 1000;
		int $ = 35;
		double $123 = 123;
		
		System.out.println(amountOf$s);
		System.out.println($);
		System.out.println($123);
		
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Anahatar sözcükler tek başına değişken ismi olarak kullanılamaz. Ancak Java'ya daha sonra eklenmiş yerine göre
 * anahtar sözcük biçiminde kullanılan bazı atomlar vardır. Bu tarz eklenen sözcükler tam anlamıyla anahtar sözcük değildir.
 * Kullanıldığı yere göre değişken ismi olup olmadığı derleyici tarafından tespit edilir (inference, deduction). 
 * Bu tarz sözcüklere programlamada "bağlamsal anahtar sözcük (contextual keywords") de denir.
 
 
 	Not: Değişken isimlerinin kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta olması gerekir.
 	
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		//int double; //error
		//double package; //error
		
		var a = 10;
		
		int var = 20;
		
		System.out.println(var);
		System.out.println(a);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

06.12.2022 Salı


/*
 * Macar notasyonu
 * Camel case(lower camel case): numberOfCase
 * Pascal Case(upper camel case): SerialPort
 * snake case (unix style): number_of_students
 * 
 * 
 * Java coding style 
 * 
 */
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Klavyeden temel türden degerler okuma yöntemlerinin tam anlamı ileride detaylı olarak ele
 * alınacak. Bu sebeple bunları bir kalıp olarak görüp yalnıca kalyeden okuma kısmı ile ilgilenecez.
 * 
 * 
 * Klavyeden int türden değer okunması kalıbı
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden int türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
 * Klaveyden double türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		
		double result = a * b;
		
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden long türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		long b = Long.parseLong(kb.nextLine());
		
		
		long result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden float türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		float a = Float.parseFloat(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		float b = Float.parseFloat(kb.nextLine());
		
		
		float result = a * b;
		
		System.out.println(result);
		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar Konusu
 * 
 * ifade(expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir dizilime ifade denir.
 * Değişkenler ve sabitler tek başına ifade belirtebilirken, operatorler tek başına ifade olamazlar. İstisna bir durum dışında
 * ifadeler hesaplandığında bir değer üretirler.
 * 
 *  a + b
 */

/*
 * Bir metodun geri dönüş degeri bilgisi yerine bir tür ismi yazılırsa bu metodun "geri dönüşü vardır" denir. 
 * Tersine bir metodun geri dönüş degeri varsa geri dönüş degeri bilgisi yerine bir tür ismi yazılır. 
 * Bir metodun geri dönüş deger varsa metot çağrısı bittikten sonra çağrıuldığı noktaya bir değer ile geri döner.
 * Bir metodun geri dönüş değeri yoksa geri dönüş değeri bilgisi yerine void anahtar sözcüğü yazılır. 
 * Bir metodun geri dönüş değeri metot içerisinde return  deyimi ile oluşturulur. 
 * 
 * return deyiminin genel biçimi:
 *  		return [ifade];
 *  
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Yani metot içerisinde akış return deyimine geldiğindemetot sonlanır 
 * ve akış çağrılan noktaya geri döner. return deyimine ilişkin ifadenin değeri çağıran metoda aktarılır.
 *  
 */


/*
 * Aşağıdaki örnekte add metodunun geri dönüş değeri 3 ile çarpılmış ve sonucu result değişkenine atanmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}






-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Java derleyicisi genel olarak bir deyime akışın hiçber zaman gelemeyeceğini anlarsa o yazılan
 * deyim için error oluşturur (unreachable code).
 */

/*
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Aşağıdaki örnekte return deyiminden sonra 
 * akış metot içerisinde kalmayacağından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
		
		System.out.println("Unreachable Code");
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * akış return deyimine geldiğinde return deyimine ilişkin ifade önce hesaplanır, elde edilen değer döndürülür
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Geri dönüş değeri olan metotolarda (void olmayan metotlarda )return tek başına kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return; //error		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur.
 * Aşaığıdaki örnekte result 10 değerinden küçük veya eşitise metot bir değer döndürmeyeceğinden error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		if(result > 10)
			return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici geri dönüş değerinin çağıran metoda aktarımı geçici değişken yaratan bir kod üretir. 
 * Aşağıdaki ** ile belirtilen kod parçası için derleyicinin ürettiği temsili kod şu şekildedir:
 * 
 * 			int temp = a + b;
 * 
 * 			returlt = temp * 3;
 * 
 * Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun
 * geri dönüş değerinin türü ile aynıdır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3; //**
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		return a + b; // int temp = a + b;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *Geri dönüş değeri olan metotolar geri dönüş degeri işleme sokulmayacak şekilde çağrılabilirler. 
 *Şüphesiz metodun da tasarımı bu kullanım açısından anlamlı olmalıdır. Aşağıdaki örnekte add metotdu klavyeden alınan 
 *değerlerin toplamını ekrana basıp aynı zamanda da değere geri dönmektedir. Programcı kodda metodun sadece ekrana basmasıyla ilgilenmiş
 *ve geri dönüş değerini kullanmamıştır. Şephesiz başka bir çağrıda kullanaılabilir.
 *
 *
 *Metot ekrana toplam değerini basmasaydı bu şekilde çağırma uygun olurmu? (işimize yararmıydı)?
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		System.out.println(result);
		
		return result;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bir metodun geri dönüş değeri başka bir motdun geri dönüş değeri olarak verilebilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getAdd();
		
		System.out.println(result);
	}
}

class Util{
	public static int getAdd()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte yine add metodunun geri dönüş değeri bir işleme sokulmuştur 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getResult();
		
		System.out.println(result);
	}
}

class Util{
	public static int getResult()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add() * 2;
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return deyimi zorunlu değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return istenirse metodu sonlandırmak için tek başına kullanılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	void metotlarda return deyimi ifade ile kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return 10; //error
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda geri dönüş değeri varmış gibi çağrılamaz. Yani void metot çağrısı geri dönüş varmış gibi işleme sokulamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.printAdd(); //error
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metot'larda parametre değişkenleri
 *
 * Metot bildirimlerinde metot isminden sonra parantezler arasında bildirilen değişkenlere "metot parametre değişkenleri"
 * ya da "parametre değişkneleri" denir. Bir metodun parametre değişkeni olmayabilir ya da istenildiği sayıda virgül ile 
 * ayrılarak bildirlebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a, int b)
	{
		//..
	}
	
	public static void printSquare(int a)
	{
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	bir metodun parametre değişkenleri aynı türden olsa bile tür bilgisi yazılmalıdır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  b) //error
	{
		//..
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenleri faaliyet alanı bakımıından metot başında bildirilen yerel değişkenler gibidir.
 * Dikkat bu cümle sadece faaliyet alanı bakımından aynı oldujlarının söylüyor. Sonuçta yerel değişken ile 
 * parametre değişlkeni aynı değildir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenlerine değerler metot çağrılır iken verilir. Metot çağırlırken bir parametreye verilen
 * ifadeye "argüman" denir. Bir metot kaç tane parametre sahipse o kadar sayıda arguman ile çağrılmalıdır. 
 * Argumanlardan parametrelere aktarım da bir atam işlemidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x, y);
		
		int result = NumberUtil.square(x);
		
		System.out.println(result);		
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metot parametre saysı kadar argüman ile çağrılmalıdır. Aksi durumda error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x); //error
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Metot çağrısında bir argüman ilişkin ifade önce hesaplanır, elde edilen değer ile metot çağrılır. Birden fazla
 *  parametreye sahip bir metot çağrısında tüm argümanlara ilişkin ifadeler hesaplanır, elde edilen değeler ile metot çağrılır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun parametre değişkeni ya da değişkenleri hem de degeri dönüş degeri olabilir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.square(NumberUtil.add(x, y));

		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir.
 *  Bu tip "compact" çözümler kodun okunabilirliğini / algılanabilirliğini etkilememelidir. Gerekirse ayrı ayrı hesaplanacak 
 *  şekilde yazılmalıdır.
 *
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.square(NumberUtil.add(x - 6, y - 5)));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	bir önceki örnek okunabilirlik/algılanabilirlik açısından aşağıdaki gibi de yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int total = NumberUtil.add(x - 6, y - 5);
		int result = NumberUtil.square(total);
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.add(x, y));
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(NumberUtil.add(x, y));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 * 
 * 
 * kötü kod bu şekilde yazılması daha doğru
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar ne işe yarar= Ya da başka bir deyişle bir problemin çözümünde neden metotlar yazalım?
 * 
 * - Bir işi çok fazla yerde yapmak kod tekrarına yol açar. Yazılım geliştirmede temel prensip "zorunlu olmadıkça
 * 	 kod tekrarı yapılmamalıdır (do not repeat yourself)" şeklindedir. Bu durumda programcı örneğin bir metot yazar ve ilgili yerlerde bu metodu çağırır.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde  "implemente" edilmişse, bu durumda programcı
 *  problemin bir değişiklik yapmak isterse veya bir hata oldgunda anlayıp düzeltmek isterse her yerde bu değişilikleri yapmak zorunda kalacaktır. 
 *  Bu çoğu zman zor olabilir.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
 *   kodun okunabilirliği de azalabilir. Yani metot çağırarak kodun okunabilirliği de artmış olur.
 * 
 * - Metot yazıldıgında başka projelere taşınarak da kullanılabilir. (code re-usability)
 * 
 * - Metodu çağıran programcı metodun nasıl yazışdıgına ilişkin detayları bilmek zorunda değildir. Çünkü metodun
 *   çağrıldığı noktada metodun nasıl yazıldıgının önemi yoktur.
 *   
 *   
 *   Not: İleride ele alacağımız "nesne yönelimli programalama tekniği"'ne ilişkin kavramlar ile kodun parçalara ayrılması metotlar
 *   dışında daha yüksek seviyede de yapılabilmektedir. Yani kabaca bu tarz programlamanın temelinde metotlar vardır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * System.out.printf metodunun ilk argümanı String olmalıdır. Metot bu argüman dışında istenilen sayıda ve istenilen türde
 * argüman ile çağıralabilir. Metodun birinci parametresine ilişkin argümanda % karateri ile birlikte geçerli
 * bazı karakterler kullanıldıgında "yer tutucu (place holder)" belirtişmiş olur. % ile birlikte kullanıma
 * "format belirleyici (format specifiers)" da denir. % birlikte kullanılan geçerli karatere ise "format karateri" denir.
 * Metot yer tutucular yerine diğer geçilen argümanlara ilişkin degerleri yerleştirir ve ekrana bu yazıyı basar. 
 * Bazı format karaterleri bir argümana ilişkin değere karşılık gelmez. Özel anlamları vardır.
 * 
 * 
 * Not: printf gibi değişkeb sayıda argüman alabilen metotlara "variadic methods" denir. 
 * Buarada bu tarz metotların nasıl yazıldıgı ele alınmayacaktır.
 * 
 */


/*
 * Tamsayı türlerinin (short, int, long, byte) decimal olarak formatlanması  d format karateri kullanılır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int degree = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece", degree);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda imleci bir sonraki starın başına geçirmek için %n kullanılabilir. %n bu anlamda bir argümana karşılık gelmez
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Arasınav notunuzu giriniz : ");
		int midtermGrade = Integer.parseInt(kb.nextLine());
		
		System.out.print("Final notunuzu giriniz : ");
		int finalGrade = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("Arasınav : %d%nFinal: %d%n", midtermGrade, finalGrade);
		System.out.println("Geçme notrunuz hesaplanıyor!....");
		//...
		//..
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodu x, X, h, H format karaterleri ile tamsayi türlerine ilişkin değerler hexadecimal olarak formatlanabilir.
 * Ayrıca o format karateri ile tamsayı türlerine ilişkin değerler octal olarak formatlanabilir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %x%n", val);
		System.out.printf("val = %X%n", val);
		System.out.printf("val = %h%n", val);
		System.out.printf("val = %H%n", val);
		System.out.printf("val = %o%n", val);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %-8d  %10d%n", val, val);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte  %08X yer tutucu için 
 * yazıulan karater sayısı 8'den kucukse geri kalanlar için sıfır yazılır 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %8d%n", val);
		System.out.printf("val = %-8d  %8d%n", val, val);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%02d/%02d/%04d%n", day, mon, year);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%2d/%02d/%4d%n", day, mon, year);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
08/12/2022

/*
 * printf metodunda gerçek sayılar (folat ve double) için f format karateri kullanılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %f%n", dval);

	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda  f format karateri ile ondalık kısmın kaç basamak olarak formatlanacağı 
 * aşagıdaki gibi belirtilebilir.
 * Geri kalan basmaklar bilimsel olarak yuvarlanır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %.3f%n", dval);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  char türü için c format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 3333;
		
		System.out.printf("c = %c%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  boolean türü için b format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  uygun format karakterlei kullanılmadıgında genel olarak exception oluşur.
 * 
 * Bu durumun istisnaları var
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %d%n", flag);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda s format karateri ile tür ne olursa olsun formatlanabilir. Şüphesiz bu durumda türe özgü
 * biçimler (hizalama vs) kullanılmaz. Bu format karakterinin ayrıntıları ileri ele alınacak
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 3.4;
		boolean c = true;
		char d = 67;
		
		System.out.printf("a = %s, b = %s, c = %s d= %s%n", a, b, c, d);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda % karakterinden sonra uygun bir format karateri getirilmelidir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %  %f%n", ratio);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda % karakteri için iki tane % karateri kullanılmalıdır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %%%f%n", ratio);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
Not: printf metodunun format karakterleri ve kullanım biçimleri oldukça geniştir. 
Burada sadece temel olanlar ele alınmıştır. Diğer format karakterleri ve kullanım biçimleri konular içerisinde ele alınacaktır.
-----------------------------------------------------------
-----------------------------------------------------------

Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
	
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindSumMultiplyApp.run();
	}
}

class FindSumMultiplyApp{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));
		System.out.printf("%d * %d = %d%n", a, b, NumberUtil.multiply(a, b));
		
	}
}

class NumberUtil{
	public static int add(int a, int b)
	{
		return a + b;
	}
	
	public static int multiply(int a, int b)
	{
		return a * b;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bölme işlemi tamsayılar ile yapıldıgında sonuç her zaman tamsayı çıkar. Elde edilen sayının noktadan sonraki kısmı
 * yuvarlanmadan atılır.
 * 
 * Tamsayılar ile bölme işleminde paydanın sıfır olması durumnda exception olusur
 * 
 * .Bu durumların detayları ileri ele alınacak
 * 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		double result = a / b;
		
		System.out.printf("%d  / %d = %f%n", a, b, result);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * format metot du ile printf tamamen aynı işlemi yapar
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.format("%d  %d %n", a, b);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 	Gerçek sayılar ile bölme işleminde payda sıfır olsa da işlem yapılır. Yani bir exception oluşmaz. Gerçek sayılar
	içerisinde genel olarak Matematik'teki "belirsizlik" için kullanılan "Not a number (NaN)" değeri vardır. Ayrıca
	genel olarak sonsuzluk (Matematik'teki tanımsızlık) için kullanılan -Infinity ve +Infinity değerleri de vardır. 
	Bu özel değerler dışında da başka özel değerler vardır. Bu durumda gerçek sayılar ile bölme işleminde pay sıfırdan
	farklı, payda sıfır ise payın işaretine göre + veya - Infinity, pay ve paydanın ikisi birden sıfır ise NaN sonucu
	elde edilir 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
		
		double result = a / b;
		
		System.out.printf("%f / %f = %f%n", a, b, result);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 	Neden standart metoları kullanmalıyız? Yani standart olarak var olan metodu programcı yazmalımıdır?
 * 	Java da standart olarak (JavaSE) bulunan metotların kullnılmasının bazı önemli avantajları varıdr:
 * 
 * 	-okunabilir kodlar yazılır
 *  -Testleri yapılmıştır ve yeterince etkin olarak yazılmıstır
 *  -Taşınabilir
 *  -Bazı metotlar (ki bunların sayısı oldukca fazladır) baska detay konularıda bilmeyi gerektirir
 *  -Programcının projede sadece kendi konusna odaklanmasıı saglar
 *  
 *   Bu durumda bir Java programcısı çözmesi gereken bir problem için JavaSE'de problemin çözümüne ilişkin metotlar varsa
 *	 onları kullanmalıdır. Yoksa yazma işlemine girişmelidir. Ancak bu druum programcının standart kullandığı metotların
 *	 nasıl yazıldığını gözardı etmesi anlamına gelmez. Programcı programlama yaşamı boyunca hepsini olmasa da hazır olarak
 *	 kullandıklarının nasıl gerçekleştirilebileceğini öğrenmelidir
 */

/*
 * Math sınıfı abs metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı sqrt metodu: Metot negatif degerler için NaN degerine geri döner
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
		
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dx = x1 - x2;
		double dy = y1 - y2;
		
		return Math.sqrt(dx * dx + dy * dy);
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfın PI ve E elemanları
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının trigonometrik işlem yapan metotları radyan ölçü birimi ile çalışır
 * 
 * Radyan ve derece arasındaki dönüşümler için toRadians ve toDegrees metotoları kullanılabilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("value: ");
		double value = Double.parseDouble(kb.nextLine());
		
		System.out.printf("sin(%f) = %f%n", value, Math.sin(Math.toRadians(value)));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f) = %f%n",a ,b ,Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n",a ,b ,Math.max(a, b));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, Math.max(Math.max(a, b), c));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.min(a, b, c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.max(a, b, c));
	}
}

class MathUtil{
	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}
	
	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f, %f) = %f%n", a, b, MathUtil.log(a, b));
	}
}


class MathUtil{
	public static double log(double a, double b) {
		return Math.log10(b) / Math.log10(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));
		System.out.printf("ceil(%f) = %.20f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %.20f%n", a, Math.floor(a));
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------,
	Sabitler (literals, constants)
	Program içerisinde doğrudan yazılan sayılara denir. Sabitlerin de türleri vardır. Derleyici sabitlerin türlerini 
	tespit ederek işlem yapar.
	
	Sabitlerin türlerinin tespitine ilişkin detaylar:
	- Sayı nokta içermiyorsa, sonuna bir ek almamışsa ve int türü sınırları içerisindeyse int türdendir. Sayı int türü
	sınırları içerisinde değilse error oluşur. 
	Örneğin: 100, 2000, 2000000000
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa long türdendir. Sayı long türü sınırları
	dışındaysa error oluşur. 
	Örneğin: 10L, 4000000000L
	
	Anahtar Notlar: Küçk harf L kullanımı 1(bir) rakamanına benzemesinden dolayı programlamada tercih edilmez. 
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve sonuna bir ek almamışsa double türdendir. Sayı double olarak ifade edilemiyor ise
	error oluşur
	Örneğin: 3.4, 6.7
	
	- Sayı nokta içersin ya da içermesin sonunda D (küçük ya da büyük) eki varsa double türdendir.
	Örneğin: 3D, 10d, 30.56D
	
	- Sayı nokta içersin ya da içermesin sonunda F (küçük ya da büyük) eki varsa float türdendir.
	Örneğin: 3F, 2f, 3.4F
	
	- boolean türden iki tane sabit vardır: true, false
	
	- char türden sabitler: İki tane tek tırnak karakteri arasında yazılan bir karakter, karakter tablosunda sıra 
	numarası belirtir. Bu şekilde yazılan sabitlere "karakter sabitleri (character literals)" denir ve bu sabitler char
	türdendir. İki tane tek tırnak karakteri arasında özel durumlar dışında birden fazla karakter yazımı geçersizdir. 
	
	Bazı karakterlerin klavyeden basılması doğrudan derleyici tarafından karakter olarak algılanamaz. Hatta bazı
	karakteler "non-printable"'dır. Örneğin bir sonraki satıra geçme karkaterinin karakter sabiti doğrudan yazılamaz.
	Bu tip bazı karakterler klavyeden doğrudan yazılamazlar. Bu tarz karakterlerin karakter sabitleri iki tane tek
	tırnak içerisinde ters bölü karakteri ile onu takip eden özel bir karakter biçiminde yazılır. Bu şekilde yazılan
	karakterlere "escape sequence" karakterler denir. Hatta bazı karakterler hem normal hem de ters bölü ile yazılabilirler:
	Java'da desteklenen escape sequence karakterler şunlardır:
	
	'\n' -> line feed (LF) 
	'\r' -> carriage return (CR)
	'\t' -> horizontal tab
	'\b' -> backspace
	'\f' -> form feed
	'\0' -> null karakter
	'\"' -> double quote (optional)
	'\'' -> single quote
	'\\' -> back slash  
----------------------------------------------------------------------------------------------------------------------*/

/*
 * char türden sabitler
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'D';
		
		System.out.println(c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * iki tane tek tırnak arasında birden fazla karater yazımı özel durumlar dışında geçersizdir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'De'; //error
		
		System.out.println(c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Line feed karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\n';
		
		System.out.printf("Marhaba");
		System.out.print(c);
		System.out.printf("Nasılsın ");
		System.out.printf("Ali");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Carriage return karater sabiti: 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\r';
		
		System.out.printf("Marhabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Horizontal tab karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\t';
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.print(c);
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Backspace karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\b'; 	
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\nNasılsın\nİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\rİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch1 = '"';
		char ch2 = '\"';
		
		System.out.println(ch1);
		System.out.println(ch2);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * İki tırnak karateri string atomu içerisinde ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\"Merhaba Ali, nasıl gidiyor\"");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Tek  tırnak karateri string atomu içerisinde dogrudan ya da ters bölü ile kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("'Merhaba Ali, nasıl gidiyor\'");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
13.12.2022 Salı


/*
 * Tek  tırnak karater sabiti ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\'';
		
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape karakterlerinden dolayı istenilen sonuç elde edilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *yukarıdaki problem aşağıdaki gibi çözümlenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\\testdata\\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *ters bölü karakterinden sonra özel karakterler dışında yazılan karakter error olusturur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *\\\\192.168.1.21\\testdata\\orhan.txt yol ifadesi "String literal" içerisinde yazılması gerek
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\\\\192.168.1.21\\testdata\\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  tek tırnak karakteri değildir -- backtick
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '`';
				
		System.out.println(ch);
		System.out.println("`Orhan OZTURK`");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü ve u karakteri ile bir karakterin sıra numarası hexadecimal olarak tek tırnak içerisinde yazıldıgında
 *  o karatere ilişkin karater sabiti yazılmış olur. Burada hexadecimal sayı kesinlikle iki byte olarak yani
 *  4 tane hex digit olarak yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\u00CB';
				
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter sabitleri "string literal" atomu içerisinde de kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Orhan OZTURK : \u1788");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter değişken isimlendirmede de kullanılabilir. Şüphesiz pratik değildir.
 *  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int \u0041\u0042\u00CB = 10;

		System.out.println(AB\u00CB);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  bir tamsayının ön eki yoksa bu durumda sabit "decimal" olarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik ıkarak sıfır ve x (buyuk ve kucuk farketmez) yazıldıgında ekten sonra gelen 
 *  basamaklar  "hexadecimal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0xA;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik sıfır yazıldıgında ekten sonra gelen 
 *  basamaklar  "octal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 012;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------


/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0b1010;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki örnekte SensorUtil sınıfının out metodu 16 tane pini olan bir elektronik devre için aldığı argüman 
	değerine göre değerin bit'lerin karşılık gelen pinleri 1 ya da sıfır için "high" ya da "low" seviyeye çekiyor olsun.
	Bu durumda böyle bir metodun alacağı sabit argümanın "binary" veya "hexadecimal" olarak yazılması okunabilirliliği
	artırır. Ayrıca yazım kolaylığı da sağlar. Aşağıdaki demo örneği yukarıdaki senaryoya göre düşününüz   
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 1.3E10;
		double b = 1.3e10;
		double c = 1.3E+10;
		double d = 1.3e+10;
		double e = 1.3E-10;
		double f = 1.3e-10;
		
		
		System.out.printf("a  = %f%n", a);
		System.out.printf("b  = %f%n", b);
		System.out.printf("c  = %f%n", c);
		System.out.printf("d  = %f%n", d);
		System.out.printf("e  = %.12f%n", e);
		System.out.printf("f  = %.12f%n", f);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double avogadroConstant = 6.02E23;
		
		System.out.println(avogadroConstant);
		System.out.printf("%f%n", avogadroConstant);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0xFC_AB_CD;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_456_123_000L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_______________________________________8L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 0b10101010_10101011_10101010_0011L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = _67; //error
		b = 43_; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sayı nokta içerisiyorsa noktadan hemen önce veya sonra alttire geçilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 6_.4; //error
		b = 4._4; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a, b;
		
		a = 5000000000L_; //error
		b = 5000000000_L; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabit önündeki eklerdeb önce sonra yada ekler arasına konulamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = 0x_AB; //error
		b = _0xAB; //error
		c = 0_xAB; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * alttire karateri octal sabitler için önek ile (sıfır ile) ilk basamak arasında geçerlidir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0_12;
		
		System.out.println(a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gerçek sayı sabitlerinin tamsayı kısmının degeri sıfır ise noktadan nce sıfır yazılmayabilir.
 * Benze şekilde sayının noktadan sonraki kısmının tamamı sıfır ise yibe sıfır noktadan sonra yazılmayabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a, b;
		
		a = .3;
		b= 3.;
		
		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yalnızca sabitlerden ve operatörleden oluşan yani içerisinde değişken olmayan ifadelere "sabit ifadesi (constant expression)" denir.
 * Buy anlamda sabit de tek başına bir sabit ifadesidir.
 * 
 * 
 * Not: İleride aslında sabit ifadesi olark kullanılabilen değişkenler de göreceğiz. Bu tarz değişknler de
 * bir ifade içersinde sabit olarak ele alınır.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		b = 20;
		
		System.out.println(NumberUtil.add(a - 2, b)); //argümanların hiçbiti sabit ifadesi değil
		System.out.println(NumberUtil.add(10 + 5, 89 - 8)); //argümanların hepsi sabit ifadesi 
	}
}

class NumberUtil{
	public static int add(int a, int b) {
		return a + b;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Derleyiciler sabit ifadelerinin değerlini hesaplayarak sonucu "byte code" a yazarlar. Bu optimizasyona
 * "constant folding optimizasyonu" denir. Bu sebeple aşağıdaki kodda 1000L * 60 * 60 * 24 * 365 ifadesinin
 * değeri byte code'a 31536000000 şeklinde yazılır. Aşağıdaki örnekte bilgi kaybı olmaması için 1000 sabitini 
 * long olarka yazılmıstır. Konuya ileride değinecez.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365; //byte code --> long divider = 31536000000;
		
		System.out.println(divider);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
			Operatörler
			
	Operatörler: Bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör denir. Operatör ile
	birlikte işleme giren ifadelere "operand" denir.
	
	Operatörleri 3(üç) biçimde sınıflandırılabilir:
	1. İşlevlerine göre sınıflandırma
		- Aritmetik (arithmetic) operatörler
		- Karşılaştırma (comparison) operatörleri
		- Mantıksal (logical) operatörler
		- Bitsel (bitwise) operatörler
		- Özel amaçlı (special purpose) operatörler	
	2. Operand sayısına göre sınıflandırma
		- Tek operandlı (unary)
		- İki operandlı (binary)
		- Üç operandlı (ternary)	
	3. Operatörün konumuna göre sınıflandırma
		- önek (prefix)
		- araek (infix)
		- sonek (postfix)
		
	Operatörün kısıtı (constraint)
	Operatörün ürettiği değer (product value)
	Operatörün yan etkisi (side effect) var mı?
	Operatörün önceliği (precedence):
	
	a = b + c * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: c * d
	i2: b + i1
	i3: a = i2
	
	a = (b + c) * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 * d
	i3: a = i2	
	
	a = b + c - d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 - d
	i3: a = i2
		
	Not: Java programcısı bir operatör için yukarıdaki durumları bilmelidir. Yani bir operatörün öğrenilmesi
	o operatör için yukarıdaki durumların bilinmesi anlamına gelir.	
	
	Not: Bazı operatörler öncelik kuralına doğrudan uymazlar. Bu tarz operatörlerin de uymadıkları durum için
	nasıl çalıştıklarının bilinmesi gerekir. Şüphesiz bu operatörlerin neden öncelik kurallarına uymadıklarının da 
	gerekçeleri (rationale) bulunur.
	
	
	Not: Operatör öncelik tablosu gruplandırma olarak düşünülebilir. Yani operatör öncelik tablosundaki öncelik
	durumlarının yapılış biçimine ilişkin istisnaları olabilir. Şüphesiz bunun da bilinmesi gerekir. Operatör öncelik
	tablosu algısal bakımdan kolaylaştırmak için vardır ve önemlidir.	

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Artimetik 4 işlem ve mod operatörleri iki operandlı (binary) ve araek (infix) operatörlerdir.
 * Bu operatörlerin ürettileri değer işlemin sonucunda elde edilen değerdir. 
 * Bu operatörlerin yan etkisi (side effect) yoktur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mod operatörünün birinci operandı negatif ise sonuç negatif çıkar. İkinci operandının negatif olmasının bir önemi yoktur.
 * Başka bir deyile mod operatörünün sonucunun işareti birinci operandının işareti ile aynıdıur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldığı en fazla 3 basamaklı int türünden bir sayının basamakları toplamına
 * geri dönen digitsSum isimli metodu NumberUtil sınıfı içerisinde yazınız. Metot aldıgı argümanın en fazla
 * 3 basamaklı olup olmadıgını kontrol etmeyecektir. Basamaklar toplamı pozitif olarak döndürecektir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		DigitsSumTest.run();
	}
}

class DigitsSumTest{
	public static void run() {
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d sayısının basamakları toplamı = %d%n", val, NumberUtil.digitsSum(val));
	}
}

class NumberUtil{
	public static int digitsSum(int val) {
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10;
		c = val % 10;
		
		return Math.abs(a + b + c);
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerinin tersini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = -a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * işaret + aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = +a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - operaörünün seviyesinde bulunan operaötlerin sagdan sole (right associative)
 * ele alınmasından dolayı geçerlidir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		int b;
		
		b = a - - - - - - - - - - 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * geçerli ifade
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a =  - - - - - - - - - - 10;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		++a; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		a++; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü prefix kullanımında ürettiği deger yani işleme giren deger arttırılmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = ++a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü postfix kullanımında ürettiği deger yani işleme giren deger arttırılMAmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a++; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		--a; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		a--; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü prefix kullanılmaktadır degeri o an azaltmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = --a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü postfix kullanılmaktadır degeri o an azaltMAmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a--; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + ++a; 
		
		System.out.printf("a = %d%n", a); // 10
		System.out.printf("b = %d%n", b); //21 //22 //20
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 3;
		
		b = a-- + ++a * a; //3 + 3 * 3 = 12
		
		System.out.printf("a = %d%n", a); // 3
		System.out.printf("b = %d%n", b); //12
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + a-- + a; //10 + 9 + 8
		
		System.out.printf("a = %d%n", a); // 8
		System.out.printf("b = %d%n", b); //27
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi
 * alacak şeklilde atomlarına ayırma işlemi yaparak (maximum munch). 
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 11;
		int c;
		
		c = a+++b; //a++ + b 
		
		System.out.printf("a = %d%n", a); 
		System.out.printf("b = %d%n", b); 
		System.out.printf("c = %d%n", c); 
	}
}

	Not: Okunabilirlik/algılanabilirlik açısından tek operandlı operatörleri genel olarak operandına
	bitişik biçimde yazacağız. İki operandlı operatörleri de özel ama önemli operatörler dışında operandları ile operatör
	arasında yalnızca bir tane "space" karakteri olacak şekilde yazacağız
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ ve -- operatörlerinin operandlarının değişken olması gerekir. Aksi durumda error oluşur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = --2;//error
		
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
15.12.2022 Perşembe

/*
 * temel karsılastırma operatorleri 6 tanedir: == , != , <, >, <= , >=
 * bu operatorlerin hepsi iki operandlı ve araek durumundadır.
 * Bu operatörlerin yan etkisi yoktur.
 * Bu operatörlerin ürettiği deger boolean türdendir. 
 * Karşılaştırmanın sonucu dogru ise true, yanlış ise false degerini üretirler.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
			
		
		System.out.printf("%d > %d -> %b%n", a, b, a > b);
		System.out.printf("%d < %d -> %b%n", a, b, a < b);
		System.out.printf("%d >= %d -> %b%n", a, b, a >= b);
		System.out.printf("%d <= %d -> %b%n", a, b, a <= b);
		System.out.printf("%d == %d -> %b%n", a, b, a == b);
		System.out.printf("%d != %d -> %b%n", a, b, a != b);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metot çağırma operatörü
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add(10, 20) * 3;
		
		System.out.printf("result = %d%n", result);
	}
}

class NumberUtil{
	public static int add(int a, int b) 
	{
		return a + b;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java da void bir metot çağrısı "void bir ifade (expression)" olarak ele alınır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.print(10, 20);
	}
}

class NumberUtil{
	public static void print(int a, int b) 
	{
		System.out.printf("%d, %d%n", a, b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * && operatörü
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() && Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return false;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * || operatörü
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * || operatörü
 * || operatörünün kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en çabuk biçimde 
	ulaşacak şekilde çalışmaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Mantıksal Operatörler 3 tanedir: &&(AND), || (OR), !(NOT)
 * 
 * && ve || operatörleri iki operandlı araek durumunda operatörlerdir. ! operatörü tek operandlı önek
 * durumunda bir operatördür. Bu üç operatörün de operandları boolean türden olmalıdır. Bu üç operatürünü ürettiği
 * deger de boolean türdendir. Bu operatörler Matematik'teki mantıksal operatörlere karşılık gelir
 * 
 */

/*
 * && ve || operatörlerinin doğruluk tablosu aşağıdaki gibidir:
	
	op1			op2		op1 && op2		op1 || op2
	T			T			T				T
	T			F			F				T
	F			T			F				T
	F			F			F				F
 * 
 * 
 * 		Yukarıdaki tabloya göre şu cümleler söylenebilir:
	"Mantıksal AND işlemi için, en az biri yanlışsa sonuç yanlıştır"
	"Mantıksal OR işlemi için, en az biri doğruysa sonuç doğrudur"
 */

/*
 * && operatörü
 * && operatörünün kısa devre davranışı (short circuit behavior). Kısa devre davranışı doğru sonuca en çabuk biçimde 
	ulaşacak şekilde çalışmaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return false;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return true;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	&& ve || operatörlerinde doğru sonuca en kısa yoldan ulaşabilmek için (yani kısa devre davranışı için) ifadenin
	önce sol tarafı yapılır. Yani bu operatörler işlem sırasında işlem önceliğine uymazlar. Ancak işlem önceliğine
	uyulursa, yani matematiksel olarak (ya da da kabaca kağıt üzerinde) elde edilen sonucu verirler. Şu cümle unutulmamalıdır:
	"&& ve || operatörleri doğru sonuca en kısa yoldan erişirler". Yani derleyici bu operatörler için buna yönelik kod
	üretir. 
	
	Aşağıdaki örnekte && operatörü || operatöründen yüksek öncelikli olmasına karşın önce || işlemi yapılır. Ancak && 
	operatörünün önceliğine göre işlem yapıldığında elde edilen sonuncun aynısı elde edilir 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() || Sample.bar() && Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte işlem sırası ile operatörlerin öncelik sırası aynıdır. Yine en soldaki önce yapılır. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() && Sample.bar() || Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bitsel AND (&) ve bitsel OR (|) operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak değer üretirler. Bu operatörler özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre 
	davranışı olmayan AND ve OR operatörleri olarak düşünülmelidir. Yine bu operatörler için de en soldaki ifade önce
	yapılır. 
	
	Aşağıdaki örnekte && ve || operatörlerleri kullanıldığında elde edilen sonucun aynısı üretilir. Ancak tüm metotlar
	çağrılır
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean result;
		
		result = Sample.foo() | Sample.bar() & Sample.tar();
		
		System.out.printf("reuslt = %b%n", result);
	}
}

class Sample{
	public static boolean foo() 
	{
		System.out.println("foo");
		return true;
	}
	
	public static boolean bar() 
	{
		System.out.println("bar");
		return false;
	}
	
	public static boolean tar() 
	{
		System.out.println("tar");
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bitsel AND (&) ve bitsel OR (|) operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerini işleme
	sokarak değer üretirler. Bu operatörler özel olarak boolean türden ifadeler ile kullanıldıklarında kısa devre 
	davranışı olmayan AND ve OR operatörleri olarak düşünülmelidir. Yine bu operatörler için de en soldaki ifade önce
	yapılır. 
	
	Aşağıdaki örnekte && ve || operatörlerleri kullanıldığında elde edilen sonucun aynısı üretilir. Ancak tüm metotlar
	çağrılır
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;
		
		c = a & b;  //00000000000000000000000000001010
		
		System.out.printf("c = %d%n", c);
		
		c = a | b;  //00000000000000000000000000001011
		
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	& ve | operatörleri tamsayılar ile kullanıldığında karşılıklı bit değerlerinin işleme sokarlar. 
	Aşağıdaki örnek durumu anlatmak için yazılmıştır. Bitsel operatörlere ilişkin ayrıntılar kullanımları burada
	ele alınmayacaktır 
 */

/*
logic and &&
bitsel and &
*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //00000000000000000000000000001010
		int b = 11; //00000000000000000000000000001011
		int c;
		
		c = a & b;  //00000000000000000000000000001010
		
		System.out.printf("c = %d%n", c);
		
		c = a | b;  //00000000000000000000000000001011
		
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Mantıksal DEĞİL (logical NOT) operatörünün doğruluk tablosu
	
	op			!op
	T			 F
	F			 T
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		flag = !flag;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Mantıksal DEĞİL (logical NOT) operatörünün doğruluk tablosu
	
	op			!op
	T			 F
	F			 T
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		boolean a = true;		
		
		a = !flag;
		
		System.out.printf("flag = %b%n", flag);
		System.out.printf("a = %b%n", a);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Atama (=) operatörü iki operandlı araek durumunda bir operatördür. Bu operatörün birinci operandı değişken olmalıdır.
	Operatörün şüphesiz yan etkisi vardır. Bu operatör sağdan sola (right associative) öncelikli gruptadır. Atama operatörünün
	ürettiği değer ikinci operandına ilişkin değerdir
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = b = c = 10;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		(a = b) = c = 10;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte atama operatörünün operandının değişken olmamasından dolayı error oluşur
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		a = (b = c) = 10; //error
		

		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte parantezin konması ve konmaması aynı anlamdadır. Çünkü atama operatörü sağdan sola önceliklidir
 */


package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 2, b = 3, c = 5;
		
		a = b = (c = 10);
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	İşlemli atama operatörlerinin genel biçimi:
	
	 <ifade1> <op>= <ifade2> ifadesinin yaklaşık karşılığı
	 
	 <ifade1> = <ifade1> <op> <ifade2>
	 
	 a += b; //a = a + b;
	 a -= b; //a = a - b;
	 a *= b; //a = a * b;
	 a /= b; //a = a / b;
	 a %= b; //a = a % b;
	 
	 İşlemli atama operatörlerinin ürettiği değer yine birinci operandına atanan değerdir
	 
	 Not: Aslında işlemli atama operatörlerinin genel biçimi tam olarak yukarıdaki gibi değildir. Bu konu
	 ileride ele alınacaktır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20;
		
		a += b;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	İşlemli atama operatörleri ifadeleri daha basit yazmak için tercih edilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;
		
		a *= b + c; //a = a * (b + c)
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	 örnekte aynı seviyede olan *= ve += operatörleri "right associative" olduğunda işlem sağdan sola doğru
	yapılır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10, b = 20, c = 30;
		
		a *= b += c; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
		System.out.printf("c = %d%n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Java 'da etkisiz ifadeler genel olarak error olusturur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		a - 2;
		
		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	ornekte error olusturmaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		Sample.foo();
	}
}

class Sample{
	public static void foo() {
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Noktalı virgül (;) sonlandırıcıdır (terminator). Genel olarak ifadeleri ayırmak için kullanılır. Java'da noktalı
	virgülden başka sonlandırıcı karakter yoktur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		++a;System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmamış değer olduğundan a sonuçta 10 olur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		a = a++;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Aşağıdaki örnekte ++ operatörünün ürettiği değer artırılmış değer olduğundan a sonuçta 11 olur. Direk ++ uygulandığındaki
	değerle aynıdır. Bu anlamda aşağıdaki kodun etkisi yoktur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		a = ++a;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
	Deyimler (Statements):
	Bir programın çalıştırılan parçalarına denir. Bir program deyimlerin çalıştırılmasıyla çalışır. Java'da deyimler
	5(beş) gruba ayrılır:
	1. Basit deyimler (simple statements)
	2. Bileşik deyimler (compound statements)
	3. Bildirim deyimleri (declaration statements)
	4. Kontrol deyimleri (control statments)
	5. Boş deyim (null/empty statements)

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Basit deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; 
		++a; //basit deyim
		System.out.printf("a = %d%n", a); //basit deyim
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bileşik deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; 
		{//bileşik deyim
			++a; 
			//...
			{
				//..
				System.out.printf("a = %d%n", a); //basit deyim
			}
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bildirim deyim
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;  //bildirim deyim 
		int b; //bildirim deyimi	
		
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Boş deyim. boş deyimin kullanıs durumları ileride ele alnıacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a; ;;;;;;
		//..
		
		;;;;;;;
		;;
		;
		;
		;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminin genel biçimi:
	if (<boolean türden ifade>)
		<deyim>
	[
	else
		<deyim>
	}
	]
	
	if deyimi, varsa else kısmı ile birlikte tek bir deyimdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) {
			System.out.println("Çift sayı girdiniz");	
		} else {
			System.out.println("Tek sayı girdiniz");
		}
		
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminde bileşik deyimi kullanımı
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0) { 
			System.out.println("Çift sayı girdiniz");
			val /= 2;
	    }else
			System.out.println("Tek sayı girdiniz");
			val *= 2;
		
		System.out.println("Ali Tekrar yapiyormusun");
		System.out.printf("val = %d%n", val);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	else kısmı olmayan if edyimi
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0)
			System.out.println("Çift sayı girdiniz");
		
		System.out.println("Ali Tekrar yapiyormusun");
		System.out.printf("val = %d%n", val);

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	if deyiminin parantezi sonuna yanlışlıkla noktalı virgül konması durumu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if (val % 2 == 0);
			System.out.println("Çift sayı girdiniz");
			val /= 2;
			
		System.out.printf("val = %d%n", val);
		System.out.println("Ali Tekrar yapiyormusun");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte else bir if deyimine ait olmadığından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val % 2 == 0)
			;
			val /= 2;
		else
			val *= 2; 
			
		
		System.out.printf("val = %d%n", val);
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val > 0)
			if(val % 2 == 0)
				System.out.println("Pozitif ve çift bir sayı girdiniz : ");
			else
				System.out.println("Pozitif bir sayi girmelisiniz");
			
		System.out.println("Ali Tekrar yapiyormusun");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte else kısmı içteki if deyimine aittir (dangling else)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		if (val > 0)
			if(val % 2 == 0)
				System.out.println("Pozitif ve çift bir sayı girdiniz : ");
			else
				System.out.println("teksayi sayı girdiniz");
		else
			System.out.println("Pozitif bir sayi girmelisiniz");
		
		System.out.println("Ali Tekrar yapiyormusun");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	if deyiminin parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(val % 2 == 0);
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)//if(even == true)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	if deyiminin parantezinde boolean türden ifadeler için == ve != operatörleri kullanılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(val % 2 == 0);
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)//if(even != false)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte isEven metodunda if deyiminin else kısmına gerek yoktur. Çünkü akış return deyimine geldiğinde
	metot sonlanır yani isEven içerisinde bir sonraki deyime geçmez. Bu durumda else yazılması iyi bir teknik değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		if(a % 2 == 0)
			return true;
		else 
			return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kodun iyi  teknikte yazılmış hali
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		if(a % 2 == 0)
			return true;
		 
		return false;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kodun daha iyi  teknikte yazılmış hali
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		
		Util.printEventStatus(NumberUtil.isEven(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class Util{
	public static void printEventStatus(boolean even) 
	{
		if(even)
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(NumberUtil.isEven(val))
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte geri dönüş değeri boolean olan bir metot çağrısı if deyiminde koşul ifadesi olarak kullanılmıştır 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(!NumberUtil.isEven(val))
			System.out.println("Çift sayi");
		else
			System.out.println("Tek sayi");
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki örnekte isOdd metodu için kod tekrarı yapılmadığına yani işi yapan başka bir metodun çağrıldığına dikkat ediniz.
	Yazılım geliştirmede "ZORUNLU OLMADIKÇA" kod tekrarı yapılmaması gerekir. Bu kavrama "DO NOT REPEAT YOURSELF" de denir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.isEven(val));
		System.out.println(NumberUtil.isOdd(val));
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

class NumberUtil{
	public static boolean isEven(int a) 
	{
		return a % 2 == 0;
	}
	public static boolean isOdd(int a) 
	{
		return !isEven(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki *** ile belirtilen if deyimi else kısmı ile birlikte tek bir deyimdir. Bu if deyiminin else kısmında 
	başka bir if deyimi vardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else
			if(val == 0)
				System.out.println("Sıfır sayısını girdiniz");
			else
				System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
	Yukarıdaki örnek daha okunabilir/algılanabilir olarak aşağıdaki gibi yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
	Aşağıdaki koşullar ayrık koşullardır. Bu durumda kod doğu çalışsa bile aşağıdaki gibi yazılmamalıdır. else-if
	biçiminde yazılması (yukarıdaki gibi) hem okunabilirdir hem de gereksiz yere kontrol edilmesi gibi durumlar oluşmaz.
	Aşağıdaki örnek şüphesiz kolay anlaşılırdır. Ancak büyük projelerde koşulların ayrık olup olmadığının anlaşılması
	aşağıdaki gibi bir yazımda zaman alabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		if(val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
	yukarıdaki kod böyle yazılmalıydı if lerin birbiri ile ilişkili oldugundan 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 0)//***
			System.out.printf("%d sayısı pozitiftir%n", val);
		else if(val == 0)
			System.out.println("Sıfır sayısını girdiniz");
		else if(val < 0)
			System.out.printf("%d sayısı negatiftir%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
	Aşağıdaki koşullar ayrık oldugunda örnek özelinde else-if biçiminde kullanılması yanlış olur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		if(val > 6)
			System.out.printf("val > 6%n");
		if(val > 11)
			System.out.println("val > 11%n");
		if(val > 21)
			System.out.printf("val > 21%n", val);
		
		
		System.out.println("Tekrar yapiyormusun ALiiii");

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
20.12.2022 Salı

/*
 * Sınıf çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerin bulup ekrana yazdıran programı yazınız.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci katsayiyi giriniz : ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci katsayiyi giriniz : ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üçüncü katsayiyi giriniz : ");
		double c = Double.parseDouble(kb.nextLine());
			
		EquationSolver.printRoots(a, b,c);
		
	}
}

class EquationSolver{
	
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double x1, x2;
		double sqrtDelta = Math.sqrt(delta);
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
	
		System.out.printf("x1 = %f,  x2 = %f%n", x1, x2);
	}
	
	public static void doWorkForSameRoots(double a, double b)
	{
		double x = -b / (2 * a);
		System.out.printf("x1 = x2 = %f%n", x);
	}
	
	public static double getDelta(double a, double b, double c)
	{
		return b* b - 4 * a * c;
	}
	
	public static void printRoots(double a, double b, double c)	
	{
		double delta = getDelta(a, b, c);
		
		if(delta > 0)
			doWorkForDifferentRoots(delta, a, b);
		else if (delta == 0)
			doWorkForSameRoots(a, b);
		else 
			System.out.println("Gercek kök yok");
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Sınıf çalışması: Katsayıları klavyeden girilen ikinci dereceden bir denklemin köklerin bulup ekrana yazdıran programı yazınız.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		EquationSolverApp.run();
	}
}

class EquationSolverApp{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci katsayiyi giriniz : ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci katsayiyi giriniz : ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("Üçüncü katsayiyi giriniz : ");
		double c = Double.parseDouble(kb.nextLine());
			
		EquationSolver.printRoots(a, b,c);
		
	}
}

class EquationSolver{
	
	public static void doWorkForDifferentRoots(double delta, double a, double b)
	{
		double x1, x2;
		double sqrtDelta = Math.sqrt(delta);
		
		x1 = (-b + sqrtDelta) / (2 * a);
		x2 = (-b - sqrtDelta) / (2 * a);
	
		System.out.printf("x1 = %f,  x2 = %f%n", x1, x2);
	}
	
	public static double getDelta(double a, double b, double c)
	{
		return b* b - 4 * a * c;
	}
	
	public static void printRoots(double a, double b, double c)	
	{
		double delta = getDelta(a, b, c);
		
		if(delta >= 0)
			doWorkForDifferentRoots(delta, a, b);
		else 
			System.out.println("Gercek kök yok");
	}
	
}



-----------------------------------------------------------
-----------------------------------------------------------
Döngü deyimleri (loop statements)

Bir işin yenilenmeli olarak yapılması için kullanılan kontrol deyimlerine denir. 
Java'da göngü deyimleri şunlardır:

1. while döngü deyimleri
	- Kontrolün başta yapıldığı while döngü deyimi (while döngüsü)
	- Kontrolün sonra yapıldığı while döngü deyimi (do-while döngüsü)
2. for göngü deyimi
3. for-each döngü deyimi (enhanced for loop, range based loop)

Not: Bu aşamadan itibaren tüm konular içerisinde "while döngü deyimi" ya da "while döngüsü" dendiğinde
	"kontrolün başta yapıldığı while döngü deyimi" anlaşılmalıdır. "Kontrolün sonra yapıldığı while döngü deyimi" için 
	kısaca "do-while döngüsü" ya da "do-while döngü deyimi" diyeceğiz 
-----------------------------------------------------------
-----------------------------------------------------------

Kontrolün başta yapıldığı while döngü deyiminin genel biçimi:

	while(<koşu ifadesi>)
		<deyim>
		
	koşuş ifadesi boolean türden olmalıdır. Bu döngü ifadesi true oldugu sürece yenilenir. 
	Akış while döngüsüne geldiğinde koşul kontrolü yapılır ve koşul gerçekleşmezse (yani tur degeri üretilmezse) döngüye girilmez.

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i);
			++i;
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		while (i < n) {
			System.out.printf("%d ", i++);
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * while döngüsü ile n-kez dönen kalıp (dizi uyumlu)
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = n - 1;
		
		while (i >= 0) {
			System.out.printf("%d ", i);
			--i;
		}
		
		System.out.printf("%ni = %d%n", i);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsü ile n-kez dönen kalıp
	 n = 3 olsun 
	 Döngünün içerisindeyken her adımda basılan n değerleri	: 2, 1, 0
	 Sayaç													: 1, 2, 3
	 Döngü sonrası n										: -1	
	 
	 Buu kalıpta n-nin döngüden sonra değerinin değiştiğine, dolayısıyla döngü öncesindeki değeri kaybettiğimize dikkat 
	 ediniz. Bu kalıp kullanılacaksa ve döngüden sonra n-nin eki değerine ihtiyaç olacaksa döngü öncesinde n değeri
	 saklanmalıdır. Bu kalıbın zorunlu olarak kullanılacağı bir durum yoktur. Ancak baz programcılar bu kalıbı kullanabilirler.
	 Böyle bir kodun anlaşılması açısında döngü kalıbı bilinmelidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
	
		while (n-- > 0) {
			System.out.printf("%d ", n);
		}
		
		System.out.printf("%ni = %d%n", n);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp atanan değerin kontrolüne
	 ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi bir kod
	 yazılabilir. 
	 
	 Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. while döngüsünün parantezi
	 içerisinde atama işleminin önceliklendirildiğine dikkat ediniz.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			sum += val;
		
		System.out.printf("Toplam : = %d%n", sum);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   while döngüsünün parantezi içerisinde bir değişkene bir metodun geri dönüş değerinin atanıp atanan değerin kontrolüne
	 ilişkin algoritmalar yazılabilmektedir. Okunabilirliği/algılanabilirliği etkilemediği sürece aşağıdaki gibi bir kod
	 yazılabilir. 
	 
	 Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. while döngüsünün parantezi
	 içerisinde atama işleminin önceliklendirildiğine dikkat ediniz.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int sum = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) { 
			sum += val;
			System.out.print("Bir sayi girinz, taki sıfır girene kadar: ");
		}
			
		
		System.out.printf("Toplam : = %d%n", sum);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Klavyeden sıfır girilene kadar alınan sayıların pozitif ve negatif olanlarının ayrı ayrı toplamını
 *   bulan programı yazınız. Programda hiç negatif veya pozitif sayı girilmemişse uygun mesajlar verilmelidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindPosNegSumApp.run();
	}
}

class FindPosNegSumApp {
	public static void printResult(int posSum, int negSum) 
	{
		if(posSum != 0)
			System.out.printf("Pozitif sayıların toplamı : %d%n", posSum);
		else
			System.out.println("Hiç pozitif sayi girmediniz!!!");
		
		if(negSum != 0)
			System.out.printf("Negatif sayıların toplamı : %d%n", negSum);
		else
			System.out.println("Hiç negatif sayi girmediniz!!!");
	}
	
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int posSum = 0, negSum = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			if(val > 0)
				posSum += val;
			else
				negSum += val;
			
		printResult(posSum, negSum);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Yukarıdaki pozitif ve negatif sayıların kaçar tane girildiğini bulan koda çevir.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		FindPosNegSumApp.run();
	}
}

class FindPosNegSumApp {
	public static void printResult(int posSum, int negSum, int posCount, int negCount) 
	{
		if(posSum != 0)
			System.out.printf("%d tane Pozitif sayıların toplamı : %d%n",posCount, posSum);
		else
			System.out.println("Hiç pozitif sayi girmediniz!!!");
		
		if(negSum != 0)
			System.out.printf("%d tane Negatif sayıların toplamı : %d%n",negCount, negSum);
		else
			System.out.println("Hiç negatif sayi girmediniz!!!");
	}
	
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Sayıları girmeye başlayınız: ");
	
		int posSum = 0, negSum = 0;
		int posCount = 0, negCount = 0;
		int val;
		
		System.out.print("Bir sayi giriniz: ");
		while ((val = Integer.parseInt(kb.nextLine())) != 0) 
			if(val > 0) {
				posSum += val;
				++posCount;
			} else {
				negSum += val;
				negCount++;
			}
		printResult(posSum, negSum, posCount, negCount);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli
 *   metodu NumberUtil isimli sınıf içerisinde yazınız ve alttaki kod ile test ediniz.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitsTest.run();
	}
}

class CountDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının basamak sayısı:%d%n", val, NumberUtil.countDigits(val));
			System.out.println("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamak sayısı:%d%n", NumberUtil.countDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		if(val == 0) // !val ile aynı şet val == 0
			return 1;
		
		int count = 0;
		
		while (val != 0) {
			++count;
			val /= 10;
		}
		
		return count;
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamakları toplamını döndüren sumDigits isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz. Metot negatif sayılar için basamakları 
	 toplamını pozitif olarak döndürecektir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		SumDigitsTest.run();
	}
}

class SumDigitsTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının basamakları toplamı:%d%n", val, NumberUtil.sumDigits(val));
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının basamakları toplamı:%d%n", NumberUtil.sumDigits(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int sumDigits(int val) 
	{
		int sum = 0;
		
		while (val != 0) {
			sum += val % 10;
			val /= 10;
		}
		
		return sum;
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının tersini döndüren reversed isimli metodu NumberUtil
	 sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 
	 123 -> 3 -> 3 * 10 + 2 = 32 -> 32 * 10 + 1 = 321
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		ReversedTest.run();
	}
}

class ReversedTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		System.out.print("Bir sayı giriniz:");
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {			
			System.out.printf("%d sayısının tersi:%d%n", val, NumberUtil.reversed(val));
			System.out.print("Bir sayı giriniz:");
		}
		
		System.out.printf("0 sayısının tersi:%d%n", NumberUtil.reversed(0));
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int reversed(int val) 
	{
		int result = 0;
		
		while (val != 0) {
			result = result * 10 + val % 10;
			val /= 10;
		}
		
		return result;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  while döngü deyiminde yanlışlıkla noktalı virgül kullanılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		
		int sum = 0;
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0);
			sum += val;
		
		System.out.printf("Toplam : %d%n", sum);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Kontrolün sonra yapıldığı while döngü deyiminin (do-while döngüsü) genel biçimi:
	 
	 do
	 	<deyim>
	 while (<boolean türden ifade>);
	 
	 Akış do-while döngüsüne geldiğinde koşul kontrolü yapılmaz. İlk adım çalıştırıldıktan sonra kontrol yapılmaya başlar.
	 Yani bu döngü deyiminin en az bir kez çalıştırılacağı garanti altındadır. while döngü deyimi kadar sık kullanılmasa da
	 okunabilirliği/algılanabilirliği artırmak ve algoritmanın sadeleştirilmesi için tercih edilebilir. Ancak bu döngü
	 deyimi gereksiz yere kullanıldığında okunabilirliği/algılanabilirliği azaltır. Buna dikkat edilmelidir

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int i = 0;
		
		do {
			System.out.printf("%d ", i);
			++i;
		} while (i < val);
		
		System.out.printf("%nDöngü sonrası :i =  %d%n", i);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
27.12.2022 Salı  11.Ders


/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 Not: İleride daha iyisi yazılacaktır

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayı giriniz:");
		int val;
		
		while ((val = Integer.parseInt(kb.nextLine())) != 0) {
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
			System.out.println("Bir sayi giriniz : ");
		}
		System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(0));
		
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   do- while döngüsünün deyimi içerisinde bildirilen bir değişken faaliyet alanı (scope)
 *   kuralları gereği koşul ifadesi içerisinde kullanılamaz

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		do {
			System.out.print("Bir sayı giriniz:");	
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   yukarıdaki problemi bu şekilde çözümleriz

 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int val;
		do {
			System.out.print("Bir sayı giriniz:");	
			val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d * %d = %d%n", val, val, val * val);
		} while (val != 0);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *    Sonsuz döngü (inifinite loop): Koşul ifadesinden dolayı sonlanmayan döngülere denir. Bu durumda hiç sonlanmayan 
	 bir döngü de sonsuz döngüdür. Tersine sonsuz döngü olarak tasarlanmış bir döngü sonlanabilecek şekilde yazılabilir

 */

/*
 * while döngüsü ile sonsuz döngü aşağaıdaki gibi oluşturulabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		while (true) {
			//..
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 Not: İleride daha iyisi yazılacaktır


	Örnekteki test kodunu sonsuz döngüye çevirelim? nasıl yaparız?
	
	Run metodunu 0 geldiğinde return deyimi ile sonlandırırsak sonsuz döngüden çıkarız
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		while (true) {
			System.out.println("Bir sayi giriniz : ");
			int val = Integer.parseInt(kb.nextLine());
			
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
			
			if(val == 0) {
				System.out.println("0 degeri geldi, run metodu sonlandırıldı");
				return;
			}
		}	
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	 for döngü deyiminin genel biçimi:
	 for ([1.kısım]; [2.kısım]; [3.kısım])
	 	<deyim>
	 	
	 1.kısım: Akış for döngü deyimine geldiğinde bir kez yapılacak kısımdır 
	 
	 2.kısım: for döngü deyiminin koşul ifadesine ilişkin kısımdır. Buraya yazılacak ifadenin boolean türden olması gerekir.
	 Bu ifade true olduğu sürece döngü yinelenir. Akış for döngü deyimine geldiğinde 1.kısım yapıldıktan sonra kontrol 
	 yapılır
	 
	 3.kısım: Döngünün bir adımı tamamlandığında bir sonraki adıma geçmek için yapılacak kontrolden hemen önce yapılır
----------------------------------------------------------------------------------------------------------------------*/

/*
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi tersten 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = n - 1; i >= 0; --i) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (i = 0; i < n; i += 2) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for dongu deyimi  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * for döngü deyiminin birinci kısmında bildirilen değişken for döngü deyimi boyunca görülebilirdir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) {
			System.out.printf("%d ", i);
		}
		
		System.out.printf("%d ", i); //error
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Aşağıdaki for döngü deyiminde "aynı faaliyet alanı içerisinde aynı isimde birden fazla yerel değişken bildirimi
	 geçersizdir" kuralı dolayısıyla error oluşur 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int i;
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { //error
			System.out.printf("%d ", i);
		}
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Aşağıdaki for döngü deyimi "farklı faaliyet alanları içerisinde aynı isimde yerel değişenler bildirilebilir" kuralı
	 dolayısıyla geçerlidir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   Döngü değişkenin değeri döngüden sonra kullanılmayacaksa döngü değişkeniş bildiriminin birinci kısımda yapılması
	 daha iyi bir tekniktir. Bu durumda döngü değişkeninin döngüden önce bildirilmesi döngüden sonra değişkenin değerinin 
	 kullanıldığı algısını oluşturur. Yani okunabilirlik/algılabilirlik artırılmış olur 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		
		for (int i = 0; i < n; i++) { 
			System.out.printf("%d ", i);
		}
		
		System.out.println();
		
		System.out.println("----------------------------");
		

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte error oluşmaz  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;
		
		for (i = n - 1; i > 0; --i); 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngü deyiminde yanlışlıkla noktalı virgül konması durumu. Aşağıdaki örnekte neden error oluşur?  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i); 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı (dizi uyumlu)  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 0; i < n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı (dizi uyumlu)  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = n - 1; i >= 0; --i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsü ile n-kez dönen döngü kalıbı 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1; i <= n; ++i) 
			System.out.printf("%d ", i);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for (int i = 1, k = 20; i <= n && k >= 0; ++i, --k) 
			System.out.printf("{i : %d, k : %d}%n", i, k);
		
		System.out.println();

	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *   for döngüsünün birinci ve üçüncü kısmında virgül ayracı ile birden fazla ifade yazılabilir 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{

		int i = 0;
		
		for (System.out.println("Birinci kısım"); i < 5; System.out.println("Üçüncü kısım"), ++i) 
				System.out.println("Deyim");
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *   for döngüsünün birinci kısmında değişken bildirimi yapılmışsa başka bir ifade yazılamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{		
		for (System.out.println("Birinci kısım"), int i = 0; i < 5; System.out.println("Üçüncü kısım"), ++i) 
				System.out.println("Deyim");
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *  for döngüsünün birinci kısmında bildirilen değişkenler aynı türden olmalıdır  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{		
		for (int i = 0, double k = 3.4; i < 5 && k > 3.8; ++i, k -= 0.03) 
				System.out.printf("{i : %d, k : %f}%n", i, k);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Aşağıdaki döngü deyimini inceleyiniz 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		int i;
		double k;
		
		for (i = 0, k = 3.4; i < 5 && k > 3.8; ++i, k -= 0.03) 
				System.out.printf("{i : %d, k : %f}%n", i, k);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünün gücü: Aşağıdaki örnekte klavyeden sıfır girilene kadar alınan sayıların toplamı bulunmuştur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		int sum = 0;
		int val;
		
		for(System.out.println("Sayıları girmeye başlayınız:"), System.out.print("Bir sayi giriniz:");
				(val = Integer.parseInt(kb.nextLine())) != 0; sum += val, System.out.print("Bir sayı giriniz: "))
			;
		
		System.out.printf("Toplam: %d%n", sum);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Hiç sonlanmayacak sanılan ancak öyle olmayan bir döngü örneği. Örnekte i değeri azalarak  -2147483648 değerine yani
	int türünün en küçüçük değeirne geldiğinde artık bir azaltıldığında 2147483647 değeri elde edilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		int i;

		for(i = 0; i < 10; --i)
			;
		
		System.out.printf("i = %d%n", i);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde birinci kısmın boş bırakılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		int i = 0;

		for(; i < n; ++i)
			System.out.printf("i = %d%n", i);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde üçüncü kısmın boş bırakılması durumu
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		

		for(int i = 0; i < n;)
			System.out.printf("i = %d%n", i++);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde birinci üçüncü kısmın boş bırakılması durumu while döngü deyimine benzetilebilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		int i = 0;

		for(; i < n;)
			System.out.printf("i = %d%n", i++);
		
		System.out.println();
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsünde ikinci kısmın boş bırakılması durumunda sonsuz döngü oluşur. Yani koşul her zaman gerçeklenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for(int i = 0; ;++i)
			System.out.printf("i = %d%n", i);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  for döngüsü ile sonsuz döngü oluşturmak için okunabilirlik/algılanabilirlik açısından 3 kısmın da boş bırakılması 
	iyi bir tekniktir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{	
		for(;;)
			;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
    Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının basamak sayısını döndüren countDigits isimli metodu 
	 NumberUtil isimli sınıf içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		CountDigitisTest.run();		
	}
}

class CountDigitisTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
					
			System.out.printf("%d sayısının basamak sayısı : %d%n", val, NumberUtil.countDigits(val));
		
			if(val == 0) {
				System.out.println("Ali Tekrarlar nasıl gidiyor?");
				return;
			}
		}		
	}
}

class NumberUtil{
	public static int countDigits(int val) 
	{
		int count = 0;
		
		do {
			++count;
			val /= 10;
			
		} while (val != 0);
		
		return count;
	}
}


/**********************************************************************************************
    Sınıf Çalışması: Parametresi ile aldığı int türden a ve b değerleri için a'nın b-inci kuvvetini döndüren pow isimli
	 metodu NumberUtil sınıfı içerisinde yazınız.
	 Açıklamalar:
	 - Math sınıfının pow metodu kullanılmayacaktır
	 - Metot negatif b değerleri için 1(bir) değerine geri dönecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Taban sayısı giriniz:");
			int a = Integer.parseInt(kb.nextLine());
					
			System.out.print("Üst sayısı giriniz:");
			int b = Integer.parseInt(kb.nextLine());
			
			System.out.printf("pow(%d, %d) = %d%n", a, b, NumberUtil.pow(a, b));
		
			if(a == 0) {
				System.out.println("Ali Tekrarlar nasıl gidiyor?");
				return;
			}
		}		
	}
}

class NumberUtil{
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for(int i = 0; i < b; i++)
			result *= a;
		
		return result;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının Armstrong sayısı olup olmadığını test eden isArmstrong 
	 isimli metodu NumberUtil sınıfı içerisinde yazınız.
	 
	 Açıklamalar:
	 - Bir sayının her basamağının basamak sayıncı kuvvetleri toplandığında sayının kendisine eşitse bu sayıya Armstrong
	 sayısı denir. Örneğin:
	 
	 153 -> 1 * 1 * 1 + 5 * 5 * 5 + 3 * 3 * 3 = 153
	 
	 - Kuvvet alma işlemi için yazılmış olan pow metodunu kullanınız
	 
	 - Sayı negatif ise Armstrong sayısı kabul etmeyiniz
	 
	 - Metodu, 1 basamaklı, 2 basamaklı, 3 basamaklı, 4 basamaklı, 5 basamaklı ve 6 basamaklı Armstrong sayılarını
	 ekrana yazdırarak test ediniz	
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = 1; a <= 999999; ++a)
			if (NumberUtil.isArmstrong(a)) 	
					System.out.println(a);
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isArmstrong(int a)
	{
		return a >= 0 && getDigitsPowSum(a) == a;
	}
	
	public static int getDigitsPowSum(int a)
	{
		int n = countDigits(a);
		int total = 0;

		while (a != 0) {
			total += pow(a % 10, n);
			a /= 10;
		}
		
		return total;
	}
	
	public static int pow(int a, int b) 
	{
		int result = 1;
		
		for(int i = 0; i < b; i++)
			result *= a;
		
		return result;
		
	}
	
	public static int countDigits(int a) {
		int count = 0;
		
		do {
			++count;
			a /= 10;
			
		}while(a != 0);
			
		return  count;	
	}
	
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 (Yavaş çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = -10; a <= 1000; ++a)
			if (NumberUtil.isPrime(a)) 	
					System.out.printf("%d ", a);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i)
			if(a % i == 0)
				return false;
		
		return true;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 Kural: Bir sayı karekökünden küçük olan asal sayıların hiçbirisine bölünmüyorsa asaldır
	 (Hızlı çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
		for(int a = -10; a <= 1000; ++a)
			if (NumberUtil.isPrime(a)) 	
					System.out.printf("%d ", a);
		
		System.out.println();
		
		System.out.println(NumberUtil.isPrime(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;

		for(long i = 11; i * i <= a; i += 2)
			if(a % i == 0)
				return false;
		
		return true;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı long türden bir sayının asal olup olmadığını test eden isPrime isimli 
	 metodu NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz
	 
	 Kural: Bir sayı karekökünden küçük olan asal sayıların hiçbirisine bölünmüyorsa asaldır
	 (Hızlı çözüm)
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		PowTest.run();		
	}
}

class PowTest{
	public static void run() 
	{
				
		System.out.println(NumberUtil.isPrime(1_000_003));
		System.out.println(NumberUtil.isPrimeSlow(1_000_003));
		
		System.out.println("Ali tekrarlar nasıl gidiyor!!!!!");
	}
}

class NumberUtil{
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;

		int count = 0;
		for(long i = 11; i * i <= a; i += 2) {
			count++;
			if(a % i == 0)
				return false;
			
		}
		
		System.out.printf("isPrime:count = %d%n", count);
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		int count = 0;
		
		for(long i = 2; i <= half; ++i) {
			count++;
			if(a % i == 0)
				return false;
		}
		
		System.out.printf("isPrime:count = %d%n", count);
		return true;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();		
	}
}

class GetPrimeTest{
	public static void run() 
	{
				
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0) {
				return;
			}
			
			System.out.printf("%d. asal sayi: %d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil{
	public static int getPrime(int n) 
	{
		int val = 2;
		
		for(int i = 2, count = 0; count < n; ++i)
			if(isPrime(i)) {
				++count;
				val = i;
			}
		
		return val;
	}
	
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;


		for(long i = 11; i * i <= a; i += 2) {
			if(a % i == 0)
				return false;	
		}
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i) {
			if(a % i == 0)
				return false;
		}
		
		return true;
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();		
	}
}

class GetPrimeTest{
	public static void run() 
	{
				
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int n = Integer.parseInt(kb.nextLine());
			
			if(n <= 0) {
				return;
			}
			
			System.out.printf("%d. asal sayi: %d%n", n, NumberUtil.getPrime(n));
		}
	}
}

class NumberUtil{
	public static int getPrime(int n) 
	{
		int count = 0;
		int val = 2;
		
		for(;;) {
			if(isPrime(val))
				++count;
			
			if(count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long a)
	{
		if(a <= 1)
			return false;
		
		if(a % 2 == 0)
			return a == 2;
		
		if(a % 3 == 0)
			return a == 3;
		
		if(a % 5 == 0)
			return a == 5;
		
		if(a % 7 == 0)
			return a == 7;


		for(long i = 11; i * i <= a; i += 2) {
			if(a % i == 0)
				return false;	
		}
		
		return true;
		
	}
	
	public static boolean isPrimeSlow(long a)
	{
		if(a <= 1)
			return false;
		
		long half = a / 2;
		
		for(long i = 2; i <= half; ++i) {
			if(a % i == 0)
				return false;
		}
		
		return true;
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     Sınıf Çalışması: Parametresi ile aldığı int türden bir sayının faktoriyel değerini döndüren factorial isimli metodu
	 NumberUtil sınıfı içerisinde yazınız ve aşağıdaki kod ile test ediniz.
	 Açıklamalar:
	 - Faktoriyel işlemi aşağıdaki gibidir: 
		 0! = 1
		 1!= 1
		 2! = 1 * 2
		 3! = 1 * 2 * 3
		 
		 ...
		 
		 n! = 1 * 2 * 3 * ... * (n - 1) * n
	 
	 - Negatif sayılar için faktoriyel değeri 1 olarak döndürelecektir	
	 
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		FactorialTest.run();		
	}
}

class FactorialTest {
	public static void run()
	{		
		for (int n = -1; n <= 25; ++n)
			System.out.printf("%d! = %30d%n", n, NumberUtil.factorial(n));
	}
}

class NumberUtil{
	public static int factorial(int n) 
	{
		int result = 1;
		
		for(int i = 2; i <= n; ++i)
			result *= i;
		
		return result;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     içiçe döngüler
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int i = 0; i < 5; ++i)
			for(int k = 10; k >= 0; --k)
				System.out.printf("(%d, %d)%n",i ,k);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     	Programcılar bazen tek bir döngü varsa da döngü içerisinde çağrılan metot veya metotlar içerisinde döngü kullanılmışsa
	içiçe döngü olacak şekilde bir kod yazmış olurlar
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int i = 0; i < 5; ++i)
			Util.print(i);
	}
}

class Util{
	public static void print(int i) {
		for(int k = 10; k >= 0; --k)
			System.out.printf("(%d, %d)%n",i ,k);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/**********************************************************************************************
     	3 basamaklı Armstrong sayılarının iç içe döngü ile bulunması
     	
     	abc -- 1-9  0-9 0-9
     	
 **********************************************************************************************/
package orhn;

public class App {
	public static void main(String [] args)
	{
		for(int a = 1; a <= 9; ++a)
			for(int b = 0; b <= 9; ++b)
				for(int c = 0; c <= 9; ++c)
					if(a * a * a + b * b * b + c * c * c == 100 * a + 10 * b + c)
						System.out.printf("%d%d%d%n", a, b, c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------
	break deyimi döngüyü, döngünün koşul ifadesinden bağımsız olarak sonlandırmak (kırmak) için kullanılır. break deyimi
	döngü deyimleri ile kullanılır ve ileride göreceğimiz "switch" deyiminde de kullanılır. Bunlar dışında kullanımı error
	oluşturur.
	
	break deyiminin genel biçimi:
	break [etiket ismi];
     	
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	break deyiminin etiketsiz kullanımında akış break deyimine geldiğinde döngü sonlandırılır. Döngüden sonraki koddan
	devam edilir. break hangi döngü içerisinde etiketsiz kullanılmışsa o döngü sonlandırılır. 
	Aşağıdkai örnekte klavyden sıfır girilene kadar alınan sayıların toplamı bulunmuştur. Sıfır girildiğinde break
	deyimi ile döngü sonlandırılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.println("Sayiları girmeye başlayınız : ");
		
		int sum = 0;
		
		for(;;) {
			System.out.print("Bir sayi giriniz : ");
			int a = Integer.parseInt(kb.nextLine());
			
			if(a == 0)
				break;
			
			sum += a;
		}
		System.out.printf("Toplam: %d%n", sum);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir n değeri için n-inci asal sayıyı döndüren getPrime isimli
	 metodu yazınız ve aşağıdaki kod ile test ediniz.
	 
	 Açıklamalar: 
	 	- isPrime metodunun hızlı versiyonunu hızlı olduğu bilinciyle getPrime metodunu yazınız
	 	- n değerinin pozitif olmaması durumu metot içerisinde kontrol edilmeyecektir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		GetPrimeTest.run();
	}
}

class GetPrimeTest {
	public static void run()
	{		
		java.util.Scanner kb = new java.util.Scanner(System.in);		
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());			
			
			if (n <= 0)				
				break;
			
			System.out.printf("%d. asal sayı:%d%n", n, NumberUtil.getPrime(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");	
	}
}

class NumberUtil {
	public static int getPrime(int n)
	{
		int count = 0;
		int val = 2;
		
		for (;;) {
			if (isPrime(val))
				++count;
			
			if (count == n)
				return val;
			
			++val;
		}
	}
	
	public static boolean isPrime(long a)
	{
		if (a <= 1)
			return false;
		
		if (a % 2 == 0)
			return a == 2;
		
		if (a % 3 == 0)
			return a == 3;		
		
		if (a % 5 == 0)
			return a == 5;
		
		if (a % 7 == 0)
			return a == 7;

		for (long i = 11; i * i <= a; i += 2)
			if (a % i == 0)
				return false;
		
		return true;		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	break deyimi yalnızca kendi döngüsünü sonlandırır. Aşağıdaki örnekte içteki döngüde bir koşul gerçekleştiğinde 
	 dıştaki döngünün de sonlandırılması flag değişken kullanılarak yapılmıştır. Örnek durumu göstermek için yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean breakAllFlag = false;
		
		for(int i = 5; i < 10; ++i) {
			for(int k = 20; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if((i + k) % 6 == 0) {
					breakAllFlag = true;
					break;
				}
			}
			
			if(breakAllFlag)
				break;
		}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak döngü deyiminin başında bir etiket bildirimi
	yapılır. Etiket bildiriminin genel biçimi:
		<etiket ismi>:
	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirirler.
	Yukarıdaki program aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
	
		EXIT_LOOP:
		for(int i = 5; i < 10; ++i) {
			for(int k = 20; k >= 0; --k) {
				System.out.printf("(%d, %d)%n", i, k);
				
				if((i + k) % 6 == 0)
					break EXIT_LOOP;
			}
		}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Etiketli break (labeled break) deyiminde gerektiğinde sonlandırılacak döngü deyiminin başında bir etiket bildirimi
	yapılır. Etiket bildiriminin genel biçimi:
		<etiket ismi>:
	Etiket ismi değişken isimlendirme kurallarına uygun herhangi bir isim olabilir. Genellikle programcılar etiket isminin
	tamamını büyük harfle, birden fazla kelimeden oluşuyorsa da araya alttire karakterini koyarak isimlendirirler.
	Yukarıdaki program aşağıdaki gibi yazılabilir
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
	
		EXIT_LOOP:
		for(int i = 5; i < 100; ++i) 
			EXIT_INNER_LOOP:
			for(int j = 0; j < 100; ++j)
				for(int k = 20; k >= 0; --k) {
					System.out.printf("(%d, %d, %d)%n", i, j, k);
					
					if((i + j + k) % 10 == 0)
						break;
					
					if((i + j + k) % 6 == 0)
						break EXIT_INNER_LOOP;
					
					if((i + j + k) % 11 == 0)
						break EXIT_LOOP;
					
				}
		
		System.out.println("Tekrar yapalım güzel olur Ali...");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	continue deyimi döngüyü değil döngünün o anki adımını sonlandırmak için kullanılır. continue deyiminin de etiketli
	biçimi vardır. Ancak yapısal programlama ve nesne yönelimli programlama tekniği açısından kullanımı tavsiye edilmez.
	continue deyiminin etiketsiz biçimi break deyimi kadar sık kullanılmasa da bazı durumlarda okunabilirlik/algılanabilirlik
	açısından tercih edilebilir. continue yalnızca döngü deyimlerinde kullanılabilir.
	
	Aşağıdaki örnekte 1 ile klavyeden girilen sayı arasındaki çift sayılar continue deyimi kullanılarak ekrana bastırılmıştır. 
	Şüphesiz daha kolay yazılabilir. Sadece continue deyiminin çalışma prensibinin anlaşılabilmesi için bu şekilde 
	yazılmıştır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int n = Integer.parseInt(kb.nextLine());
		
		for(int i = 1; i <= n; ++i) {
			if(i % 2 != 0)
				continue;
			
			System.out.printf("%d ", i);
		}
		
		System.out.println("\nÇok çalışalım Erken uyuyalım Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulması iskeleti yazıldı
	(ileri daha iyisi yazılacak)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(option < 1 || option > 5) {
				System.out.println("\"Geçersiz seçenek\"");
				continue;
			}
			
			if(option == 5)
				break;
			
			doWorkFor(option);
		}
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{
		if(option == 1)
			doWorkForInsert();
		else if(option == 2)
			doWorkForUpdate();
		else if(option == 3)
			doWorkForDelete();
		else
			doWorkForList();
		
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Basit bir menü uygulması iskeleti yazıldı
	(ileri daha iyisi yazılacak)
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		MenuApp.run();
	}
}

class MenuApp{
	public static void run() 
	{
		Menu.run();
	}
}

class Menu{
	public static void run() 
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for(;;) {
			printMenu();
			int option = Integer.parseInt(kb.nextLine());
			
			if(1 <= option && option <= 5) {
				if(option == 5)
					break;
				
				doWorkFor(option);
			} 
			else
				System.out.println("\"Geçersiz seçenek\"");
		}
		System.out.println("Teşekkürler");
	}
	
	public static void printMenu() 
	{
		System.out.println("1.Ekle");
		System.out.println("2.Güncelle");
		System.out.println("3.Sil");
		System.out.println("4.Listele");
		System.out.println("5.Çıkış");
		System.out.print("Seçenek:");
	}
	
	public static void doWorkFor(int option) 
	{
		if(option == 1)
			doWorkForInsert();
		else if(option == 2)
			doWorkForUpdate();
		else if(option == 3)
			doWorkForDelete();
		else
			doWorkForList();
		
	}
	
	public static void doWorkForInsert() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Ekle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForUpdate() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Güncelle\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForDelete() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Sil\" seçildi");
		System.out.println("---------------------------------");
	}
	
	public static void doWorkForList() 
	{
		System.out.println("---------------------------------");
		System.out.println("\"Listele\" seçildi");
		System.out.println("---------------------------------");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı n sayısı için n-inci Fibonacci sayısını döndüren fibonacciNumber isimli 
	metodu NumberUtil sınıfı içerisinde ve aşağıdaki kod ile test ediniz
	Açıklama:
		- Fibonnaci sayıları
			0 1 1 2 3 5 8 13 21 34 ...
		- Metot pozitif olmayan n değerleri için kontrol yapmayacaktır
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		FibonacciNumberTest.run();
	}
}

class FibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int n = Integer.parseInt(kb.nextLine());
			
			if (n < 1)
				break;
			
			System.out.printf("%d. Fibonacci sayısı:%d%n", n, NumberUtil.fibonacciNumber(n));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil{
	public static int fibonacciNumber(int n) 
	{
		if(n <= 2)
			return n - 1;
		
		int prev1 = 1, prev2 = 0, val = 0;
		
		for(int i = 2; i < n; ++i) {
			val = prev1 + prev2;
			prev2 = prev1;
			prev1 = val;
		}
		
		return val;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------	 
	Sınıf Çalışması: Parametresi ile aldığı int türden bir sayıdan büyük ilk Fibonacci sayısına geri dönen nextFibonacciNumber
	isimli metodu yazınız ve aşağıdaki kod ile test ediniz
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		NextFibonacciNumberTest.run();
	}
}

class NextFibonacciNumberTest {
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		for (;;) {
			System.out.print("Bir sayı giriniz:");
			int val = Integer.parseInt(kb.nextLine());
			
			if (val < -999)
				break;
			
			System.out.printf("%d. sayısından büyük ilk Fibonacci sayısı:%d%n", val, NumberUtil.nextFibonacciNumber(val));
		}
		
		System.out.println("Tekrar yapıyor musunuz?");
	}
}

class NumberUtil {
	public static int nextFibonacciNumber(int val) 
	{
		if (val < 0)
			return 0;
		
		int prev1 = 1, prev2 = 0, next;
		
		for (;;) {
			next = prev1 + prev2;
			
			if (next > val)
				return next;
			
			prev2 = prev1;
			prev1 = next;
		}
	}	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*----------------------------------------------------------------------------------------------------------------------	 
	switch deyiminin genel biçimi:
	switch (<ifade>) {
		case <sabit ifadesi>:
			<deyim>
		case <sabit ifadesi>:
			<deyim>
			
		...
		
		[
		default:
			<deyim>
		]			
	}
	
	Bu deyimde parantez içerisindeki ifade temel türler için tamsayı türlerinden biri veya char türünden olabilir.
	Temel türler dışında String veya enum türlerinden de olabilir. Bu türler ileride ele alınacaktır. switch 
	deyiminin default kısmı zorunlu değildir.
	
	
	Anahrtat Notlar: switch deyimi Java 12'den itibaren ifade (expression) olarak da kullanılabilmektedir. Bu tarz 
	deyimlere/ifadelere "ifadesel deyim (expression statement)". switch'in ifade olarak kullanılmasına yönelik sentaks
	ve semantik eklentiler yapılmıştır. İleride ele alınacaktır.  
----------------------------------------------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------------------------------------------	 
	Aşağıdaki switch deyiminin if deyimi karşılığı:
	
	if (postalCode == 34387)
		System.out.println("Mecidiyeköy");
	else if (postalCode ==  67100)
		System.out.println("Zonguldak Bahçelievler");
	else
		System.out.println("Geçersiz posta kodu");
----------------------------------------------------------------------------------------------------------------------*/

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Posta kodunu giriniz:");
		
		int postalCode = Integer.parseInt(kb.nextLine());
		
		switch (postalCode) {
		case 414100:
			System.out.println("Gebze");
			break;
		case 37100:
			System.out.println("Kastamonu Merkez");
			break;
		default:
			System.out.println("Geçersiz posta kodu");
		}
		
		System.out.println("Tekrar yapıyor muyuz ALİ?");	
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------
