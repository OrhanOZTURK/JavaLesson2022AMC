15.11.2022

Java Eğitimi

Java Ders programı
Salı - Perşembe
Saat: 19:00 - 22:00


github'ta ders notları yedeklenecek.


1- Java Genel giriş 
2- Java özellikleri
3- Genel programlama pradigmaları
4- Sayı sistemleri
5- Bir java programı text sayafasına yazıp derleyip çalıştıracaz


HW1
-Assembly nedir neden var neden kullanımda hala?
-Unity ve Unreal Engine nedir ve diger oyun motorlarına inceleyelim.
-Interpereted programlama dili nedir?
-Garbage Collector Nedir nasıl çalışır?
-Memory leak
-Functional Programming, Prosedürel Programlama, Object Oriented Programming,
    Generic Programming, Imperative programming, Reflective programming, Concurrent
-Java programı derleme ve çalıştırma adımları
    JVM nedir 
    JRE nedir 
    JIT nedir 
    Byte code nedir 

    Bunlar hangi aşamalardan geçerken kullanılıyor?



ali olustur 
..
..

ali silindi progaramcı silmesin ben silerim G.C devereye giriyor 

C ve C++ da Garbage C. mekanizması yoktur. Programcı kendi siler kendi olsuturdugu nesneyi.


Programlama Dillerinin Sınıflandırılması

Programlama dillerini 3(üç) biçimde sınıflandırabiliriz:
1. Seviyelerine göre sınıflandırma

2. Kullanım alanlarına göre sınıflandırma

3. Programlama modeline göre sınıflandırma



Java programı derleme ve çalıştırma adımları





--------------------------------------------------------

HW2 

Stack ve Heap Nedir ?
Donanımsal karsılıkları?

Fonksiyonel programlama ile prosüdürel programlama arasındaki fark?
Imperative Programing?
Reflective programing?
Concurrent programing? 


--------------------------------------------------------
22.11.2022


HW3 
Github reopsu olusturmak kendi java norları için
Github'a kendini anlatan bilgi veren sade bir Overwiev olustur.
Google documentler den slaytları hazırlayalım

--------------------------------------------------------
/*******************************************************/
/*******************************************************/


Sayı Sistemleri 


2-8-10-16 temelde bu sayı sistemleri var 


2 lik sayı sistemi 

Neden kullanırız: tam sayı ve gerçek sayı sistemleri için kullanırız

4 66 76  -- 123,4 555.7


0101 1011 0001 1110 

ikilik  sayı sistemi işaretli ve işaretsiz olmak üzer iki gruba ayrılır 

işaretsiz - unsigned --> sayının pozitif oldgunu söyleer
işaretli -- signed ---> sayıların hem pozitif hem negatif olabiliceğini söyler 


Sistemlerin hemen hepsinde 

8 bitlik alana byte denilmektedir.

bit bit bit bit bit bit bit  bit
1   0   1    0   1   1   0   0  === byte 

bit = binary digit 
Byte = 8bit

Sistem programlamada daha küöçük birimler var 

4 bit = Nibble = yarım byte
8 bit = byte 
2 byte = word
4 byte = double word


Sayı sistemlerinde bazı işlemler

2'ye tümleyeni bulma konusu için pratik kurallar 

	0101  0100
	1010	 1100

sagdan baslayarak ilk 1 bitini gorene kadar 
bitlerin aynısını yazıyoruz
geri kalan kısmı ters ceviriyoruz
	

	0001  1000
     1110  1000    

---------------------
işaretli 2 lik sistem

sign bit --> sayının işaretni belirler
0 --> pozitif sayı
1 --> negatif sayı


işaretli sayı sistemlerinde 
Sistemlerin hemen hepsi negatif sayıyı gösterimi için
Sayının 2'ye tümleyini aritmatigi kullanır

aynı sayıınn pozitif ve negatif degerleri
sayının 2 ye tümlenyenleri

45
-45 gibi 

1110 1001 = -23
2^0 * 1 + 2^1 * 0 + 2^2 * 0 + 2^3 * 1 + 2^4 * 0 + 2^5 * 1 + + 2^6 * 1 + 2^7 * 1
0001 0111 = 23


Soru :  bir byte lık alanda -52 sayısını ifade edermisin

önce 52 degerinin bitlerini buluruz sonrada 2'ye tümelyeni buluruz. Eksili sayının 2 bitlik ifadesini 

0011 0100 = 52
1100 1100 = -52


---------------------------------------------
temel byte alanlarında yazılabilecek en buyuk ve en kucuk degerler 

unsigned sistemde

0  - 255
0  - 65535
0  - .....


signed sistemlerde

0111 1111 -- > 127 en buyuk tam sayı degeri 
1000 0001 ---> -127 - 1 = 128 en kucuk tam sayı degeri elde edilir 
1000 0000 --> -128


-128 127
-32768 - 32767
-2147483648  - 2147483647 

--------------------------------------------------------------

Soru: İşaretli 2 lik sayı sisteminde butun bitleri 1 olan sayı nedir

1111 1111 = -128 + 127 = -1
0000 0001 = 1 


--------------------------------------------------------------

16 LIK sayı sistemi 

hexadecimal sistem 
hex system denir 

16 tane sembol var

0123456789ABCDEF


Neden hex sistemi bizi ilgilendirir

aslında 2 lık sayı sisteminde 5 bitlik alanı tekbir yerde gosterebiliriz
ayrıca 16 lık sistem 2 nın katı olması işimizi kolaylaştırır



Soru: 2lık sayı sistemini 16 lık sayı sistemine cevirelim

1001  1110 1001 1111
  9    E    9    F

Soru:  1AC  onluk sayı sistemine donusturelim

1*16^2 + 10 * 16^1 + 12 * 16^0  = 256 + 160 + 12 = .....


-----------------------------------------------------------

Önce java gereksinimleri yuklenmeli işletim sistemine göre

Sonra 
Java ayarlarımızı consol'dan incelemeliyiz aynı versiyon olmalı  

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>java -version
java version "17.0.1" 2021-10-19 LTS
Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing)

C:\Program Files (x86)\Microsoft Visual Studio\2019\Community>javac -version
javac 17.0.1

-----------------------------------------------------------


Dil kavramı nedir?

Dil iletiişmde kullanılan semboller toplulugudur. Bir dilin kurallarına gramer denir.
Gramerin bir çok alanı vardır. En önemlileri "sentaks (syntax) " ve "semantik (semantic" dir.
Bir cümlenin olabilmesi için en azından sentaks ve semantiğe sahip olması gerekir.


Sentaks doğru yazma ve dogru dizilime ilişkin kurallardır.

		"I going to will fitness."

Java ornegi 

		System.out.println("Hello, World)";


Semantik: Dildeki dogru dizilmiş ögelerin ne anlama ifade ettiketlerine ilişkin kurallara da semantik denir.


Dipnot:
Bilgisayar Dilleri ve Programlama Dilleri: Bilgisayar bilimlerinde kullanılmak üzere tasarlanmış
dillere bilgisayar dilleri (computer langues) denir. Bir bilgisayar dilinde akış da varsa o zaman programalam dili
(programmin language) denir. Örnek: HTML, XML gibi bilgisayar dilleridir, programlama dili değildir.
C, C++, Java, C#, Swift..... gibi dillerde akış oldugunda programlama dilleridir. 


-----------------------------------------------------------

Hello World Program


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}


komutlar

-> javac orhn/App.java

-> java orhn.App


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

29.11.2022 Salı

Derleyici hata mesajları (diagnostics):

1. Gerçek hatalar (Error): Dilin sentaks ve semantik kurallarına uyulmamasından dolayı verilen mesajlardır.
	Bu durumda arakod(Byte code) üretilmez.

2. Uyarılar (warning): Byte kodun üretimine engel olmayan, olası programlama ve mantık hatalarının programcıya
	bildirilmesi içien verilen mesajlardır. Programcı bu uyarıları mutlaka dikkate almalıdır. Özel bir durum yoksa 
	uyarı mesajlarının oluşumuna yol açan kodlar düzeltilmelidir. Bazı duurmlarda derleyicinin uyarı mesajı verdiği ancak IDE'nin kullanıldıgı
	bir "static kod analizi araçları" konfigürasyonları gereği uyarı verebilirler. Şüphesiz bunlarda da dikkate alınmalıdır. Ancak bunların
	hepsi düzeltilmesi gerekmez.


3. Ölümcül hatalar (fatal errors): Derleme işleminin bile tamamlanmasını engelleyebilecek hatalardır. Bu durumda
	programcının yazdıgı kod açısından yapacak bir şeyi yoktur. Çünkü kod henüz derlememiştir. Programcının ölümcül hataya
	yol açan durumu ortadan kaldırmsı gerekir. Örneğin diskte yer kalmaması, derlenecek dosyanın bulunamaması gibi durumlar ölümcül hatalara örnek gösterilebilir.


Programın çalışma zamanı sırasında oluşan hatalara genel olarak "exception" denir. Exception oluştugunda program sonlanır. 
Bu durum detayları "exception işlemleri(exception handling)" konusunda ele alınacaktır. Excepiton yerine "run time error" da kullanılabilrmektedir. 
"error" denildiginde "compile time error" anlaşılır.
  

-----------------------------------------------------------

Java'da yorum satırları (comment lines)


Not: Yorum satırları kodun okunabilirliğini/algılanabilirliğini bozacak şekilde koda eklenmemelidir
	Yorum satırı eklemenin de bir "convetion"'u olmadır.

package orhn;

class App{

    //Burası derleyici tarafından dikkate alınmaz.
    public static void main(String[] args) {
        System.out.println("Hello, World");    

        /*
            Burası da 
            derleyici
            tarafından 
            dikkate alınmaz 
         */
    }
}

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Atom (Token):
Bir programlama dilinde kendi başına anlamlı olan en küçük birime atom denir. Atomlar 6 gruba ayrılır.

1. Anahtar Sözcükler(keywords, reserved words): Dil için özel bir anlamı olan yeni dil tarafın bilinen ve 
	birçoğu doğrudan değişken ismi olarak kullanılamayan atomlardır. Örneğin: package, class, public, int, if, while vs.

2. Değişkenler (identifiers, variables): İsmini programcının belirlediği ve çeşitli kurallara göre isminin berlirlenebildiği atomlardır.
	Örneğin: App, String, System, orhn vs...

3. Operatörler (Operators): Bir işleme yol açan ve bu işlem sonucunda bir değer üreten atomlardır.
	Örneğin: a + b ifadesinde + bir operatordür

4. Sabitler (Literals, constants): Program içerisine doğrudan yazılan sayılara denir. Örneğin: a - 5 ifadesinde
	5 bir sabittir. 

5. String'ler (Strings, String Literals): iki tırnak (double quote) içersinde bulunan yazılar tırnaklarla birlikte string atomudur.
	Bu atoma string sabiti anlamında "string literal" da denir. Örneğin: "Hello, World"

6. Ayraçlar (delimiters, punctuators): Yukarıdaki gruplar dışında kaln tüm atomlara denir. Örneğin: {}, (), [] vs.

-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Programı atomlarına parçalayalım


package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
    }
}

package 		->  anahtar sözcük
orhn			-> değişken
class		-> anahtar sözcük
App			-> değişken
{}			-> ayraç
public		-> anahtar sözcük
static		-> anahtar sözcük
void 		-> anahtar sözcük
main			-> metod ismi değişken
()			-> ayıraç
String		-> değişken
[]			-> ayıraç 
args			-> değişken
{}			-> ayıraç
System		-> değişken
.			-> operator
out			-> değişken
println		-> değişken
()			-> metod çagırma operatoru
"Hello, World" -> String literals
;			-> Ayıraç


-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------

Boşluk karakterleri (whitespaces): Klavyeden basılıgında bosluk algısı veren karakterlerdir.
	Klavyeden basılan bosluk karakterleri tipik olarak sunlardır: space, tab, enter 

-----------------------------------------------------------
-----------------------------------------------------------

	Java programlama dilinde kod yazım kuralları şunlardır:
	1. Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.
	2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.


-----------------------------------------------------------
-----------------------------------------------------------

Atomlar arasında istenildiği kadar boşluk (whitespace) bırakılabilir.


package 



orhn;

class 







App{

    public static void main(String[


    ] 
    
    args) 
    
    {
        System.             out.            println("Hello, World");    

    }
}


-----------------------------------------------------------
-----------------------------------------------------------

2. Anahtar sözcükler ve değişkenler dışında kalan atomlar istenildiği kadar bitişik yazılabilir. 
		


package orhn;class App{public static void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Anahtar sözcükler ve değişken atomlar arasında en az bir boşluk (whitespace) karateri olmalıdır.

package orhn;class App{publicstatic void main(String[]args){System.out.println("Hello, World");}}


-----------------------------------------------------------
-----------------------------------------------------------

Not: Java'da derleme zamanı (compile time) ve çalışma zamanı (run time) denilen birbiriyle ilişkili
	ancak ayrı olan iki kavram vardır. Derleme zamanı derleme sürecinde yapılan işlemlere denir. 
	Çalışma zamanı programın çalışma sürecinde yapılan işlemlere denir.

-----------------------------------------------------------
-----------------------------------------------------------

Bildirim (declaration): Bildirim bir ismin derleyiciye tanıtılmasıdır. 
				    Derleyici bildirim ile o ismin ne anlama deldiğini anlar ve derleme işlemini ona göre yapar.


-----------------------------------------------------------
-----------------------------------------------------------

Bir java programı genel olarak paketlerden, paketler sınıflardan, sınıflarda metodlardan oluşur.

package <isim>;
Örnek:
package orhn;


class <isim> {


}

Örnek:

class Sample{
	//...
}


class Mample{
	//...
}





-----------------------------------------------------------
-----------------------------------------------------------
Metod bildirimlerin genel biçimi:

Java'da alt programlara metot (method) denir. Alt programın ne yapacağının yazılmasına "metot bildirimi (metot declaration)" denir.
Alt programın kodlarının çalıştırılmasına ise "metot çağırma (method call)" denir. Metot bildirimini genel biçimi:

[erişim belirleyici] [static/non-static] <geri dönüş değeri bilgisi> <metot ismi>([parametreler])
{
	//...
	//...

}

Açıklamalar:

-Erişim belirlemeleri şunlardan biri olabilir: public, protected, private, no-modifier(hiçbir şey yazılmaması)
	Metotların erişim berlirleyicileri konusuna gelene kadar tüm metodları public olarak bildirecez.

- Bir metot static veya non-static olabilir. static anahtar sözcüğü bildirimde yazılmasa metot non-static olur.
	non-static metotlara ilişkin konuya gelene kadar tüm metotları static olarak bildirecez.

- Metodun geri dönüş değeri bilgisi metot isminden önce yazılmalıdır. Metodun geri dönüş değerinin olmaması durumuda
	void yazılması demektir. Geri dönüş degerı kavramı da ileride ele alınacaktır.
- Metodun ismi bir değişken atomdur. Tğm değişken atomlarda oldugu gibi "değişken isimlendirme kuralları"na uygun 
	olarak isimlendirilmelidir.
-Metot bildirimlerinde motot isminden sonra parantezler içerisinde ismine "parametre (parameter)" deniken değişkenler bildirilebilir.
	Metot parametre değişkenleri ileride ele alınacaktır.
- Metot bildiriminde küme paratezleri arasında (metot gövdesi) metodun kodları yazılır 


static bir metodun çağrılmasının genel biçimi:

[paket ismi].[sınıf ismi].<metot ismi>([argümanlar]);


Bir program main metodunun çağrılmasıyla çalışmaya başlar. Programcının main metodu içerisinde çağırdığı motolar ve o metotların içerisinde çağrılan motolarla
akış devam eder. main metodu JVM tarafından çağrılır. Bu anlamda java programına verilen "byte code"'a ilişkin sınıfın main metoduna "giriş noktası (entry point)"
denir. Özel bazı özel durumlar dışında (bu özel durumlar vardı - extrem konularda karsımıza cıkar) main metodu sonlandıgında program sonlanır.
Bir metot çağrıldıgında akış metodun kodlarına dallanır (call) ve metodun kodları çalıştırılır. Şüphesiz metot içerisinde başka bir metot çağrılıyor olabilir.
Yine bu çapırma n0oktasında akıl metodun kodlarına dallanır. Metot çağrısı sonlandıgında akış metodun çağrıldıgı noktaya geri döner ve bir sonraki koddan akış 
çalışmaya devam eder.

Not: System.out.println("Hello World"); çağrısında System bir sınıf, out bir referans ve println de non-static bir metotdur.
	Bu kavramları ileride ele alacagız.

-----------------------------------------------------------
-----------------------------------------------------------

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        orhn.Sample.foo();
        orhn.Sample.bar();
        orhn.Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        orhn.Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------

Çağıran metodun (caller) ait oldugu sınıf ile çağıran metot (callee) ait oldugu sınıf 
aynı paket içerisindeyse çağırma sırasında paket ismi yazılmayabilir

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}
-----------------------------------------------------------
-----------------------------------------------------------
Çağıran metot ile çağrılan metot aynı sınfta ise bu durumda çağırma sırasında paket ismi yazılmamışsa sınıf 
ismide yazılmayabilir.

package orhn;

class App{
    public static void main(String[] args) {
        System.out.println("Hello, World");    
        Sample.foo();
        Sample.bar();
        Mample.tar();
        System.out.println("Goodbye, World");
    }
}

class Sample{
    public static void foo()
    {
        System.out.println("Sample.foo");
        Mample.tar();
    }

    public static void bar()
    {
        System.out.println("Sample.bar");
        foo();
    }
}


class Mample {
    public static void tar()
    {
        System.out.println("Mample.tar");
    }
}


-----------------------------------------------------------
-----------------------------------------------------------
01.12.2022 Perşembe

IDE (Integrated Development Environment): Derleyiciler komut satırından çalıştırlabilen basit bir arayüze sahip
programlardır. Aslında teorik olarak java ile geliştirilecek bir uygulma içerisinde tüm java dosyları "notepad"
basit bir editor ile yazılıp, komut satırından derlenebilir. Fakat pratikte bu şekilde program yazman fazlaca 
zaman kaybettirir. Yazılım geliştirmeyi kolaylaştırmak için IDE debilen programlar kullanılır.
IDE'ler içerisinde editorler, test araçları, çeşitli kodlar üreten araçlar vs. bulunur. IDE bir derleyici değildir.
IDE derleme işlemi için derleyiciyi de çalıştırabilir. Uygulamayı çalıştırma işlemi için de yineJRE içerisindeki araçları 
kullanabilir. Java ile uygulma geliştirirken kullanılabilecek çeşitli IDE'ler bulunmaktadır. Bunlardan en yaygın 
kullanılanları "Eclipse" ve "IntelliJ IDEA" IDE'leridir. Önceleri Netbeans isminde bir IDE kullanılmaktaydı. 
Ancak Netbeans kullanımı oldukça azalmıştır.

-----------------------------------------------------------
-----------------------------------------------------------
Tür (type): Bir değişken için bellekte kaç byte ayrılacağını ve içerisindeki hangi
yöntemle veri tutulacagını belirten kavramdır.

Java'da türler genel olarak iki gruba ayrılabilir.
Temel türler (primitive/built*in/predefined types).
Programcının tanımladığı türler (user defined types).


Temel türler

Tür ismi			Uzunluğu(byte)
short				2
int					4
long				8
byte				1                           0 0 0 0  0 1 0 1  --> 5    ------- -128/127

float				4
double				8

char				2
boolean				-


-Java da türlerin uzunlukları boolean türü dışında sistemden sisteme değişmez.

-Tüm tam sayı türleri işaretlidir(signed)

-Tamsayı türleri (integer/integral types) için ikiye tümleme yöntemi kullanılır. Java'da işaretsiz tam sayı türleri yoktur.
Ancak java 8 ile birlikte belirli koşullar altında işaretsiz tamsayı işlemleri yapılabilmektedir.

-long türü en uzun tamsayı türüdür.

-Gerçek sayı(real/floating point types) için "IEEE 754 standardı" kullanılır. float ve double türleri sırasıyla
tek hassasiyetli (single precision) ve çift hassasiyetli (double precision) değerleri tutmaktadır. Bu türlerde bazı sayılar
tam olarak ifade edilemezler 0 sayıya yakın bir sayı ile ifade edilebilirler. Bir noktalı sayının ifade edilemeyip en yakın
sayı olarak ifade edilmesine yuvarlama hatası (rounding error) denir. Yuvarlama hataları değer ilk kez yerleştirilirken
de oluşabilir, bir işemin sonucunda da oluşabilir.


-Gerçek sayı türleri işaretli türlerdir.

-float türünün yuvarlama hatalarına karşı direnci zayıfır. Yanı yuvarlama hatası daha çok olmaktadır.

-Yuvarlama hataları parasal ve finansal uygulamarda hatalı değerlerin oluşmasına sebep olabilir. Sırf parasal
ve finansal uygulamalar için tasarlanmış özel türler (sınıflar) bulunur. Programcı böylesi uygulamalar için bu sınıfı
tercih eder. Ancak bu sınıflar yuvarlama hatası yapmamak için yüzlerce makine komutu ile bu işlemleri yapar.
Bu durumda programcı için parasal ve finansal uygulamalar gibi yuvarlama hatasının olmaması gerekn uygulamalar dışında double
yada durma göre float türü tercih edilmelidir.


-char türü Java'da UNICODE tablo dikkate alınarak belirlenmiştir. Bu nedenle char türü 2 byte'dır. char türünden 
değişken içerisinde bir karakterin UNICODE tablosu (ya da başka tablodaki) sıra numarası tutulur. UNICODE tablo
dünyadaki dillerde kullanılan hemen hemen tüm karakterleri ve bazı özel karakterleri ifade edebilme yeteneğine sahiptir.


-Yazılar içerisinde her bir karakter aslında bir sayı ile temsil edilir. Hangi karakterin hangi sayı ile ifade edildiği
karater tablosuna bağlıdır. ASCII tablosu 1 byte'lık yani 256 tane satırdan oluşur. UNICODE tablo 2 byte'lık
yani 65536 satırdan oluşan bir tablodur. Karakter tablolları bunlarla sınırlı değildir.


-boolean türünün alabileceği iki tane değer vardır: true, false. boolean türünün uzunluğu "Java Language Specification"'da
belirtilememiştir. Sistemden sisteme değişebilir. Ancak bu değişim programcı açısından problem oluşturmaz.

Not: int türüne "integer" demek yanlış bir terim kullanamk demektir. integer terimi tamsayılar için
kullanılan genel bir terimdir. Ayrıca "Integer" isimli bir sınıf da bulunmaktadır.

Not: Java'da en çok kullanılan tamsayı türü int türüdür. en çok kullanılan gerçek sayı türü de double türüdür.
Programcı öncelikle bu türleri tercih etmelidir. Eğer geçerli bir nedeni varsa diğer türleri kullanabilir.

-----------------------------------------------------------
-----------------------------------------------------------
HW3

IEEE 754 standardı nedir? 
Gerçek sayılar bu standarda göre nasıl ifade edilir?

1344.3454 ---> bunun sistemde nasıl ifade edildiği 
		   veya javada nasıl ifade edildiğini ögrenecez


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 0.1, b = 0.2;
		double c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki yuvarlama hatası örneği inceleyelim.  
 * İleride detaylı olarak ele alınacak
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		float a = 0.1F, b = 0.2F;
		float c;
		
		c = a + b;
		
		if(c == 0.3)
			System.out.println("Eşit");
		else
			System.out.println("Eşit değil");
		
		System.out.printf("a = %.20f\n", a);
		System.out.printf("b = %.20f\n", b);
		System.out.printf("c = %.20f\n", c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
Bir değişken kullanılmadan önce bildirilmelidir:
Değişken bildiriminin genel biçimi:
<tür> <değişken ismi>;

örnek:

int a;
float b;
boolean c;

-----------------------------------------------------------
-----------------------------------------------------------
Java'da 3 çeşit değişken vardır:
1. Yerel değişkenler (local variables)
2. Parametre değişkenleri (Parameter variables)
3. Sınıf veri elemanları (class member variables)


Değişkenler için temel kavramlar:
İsim(name): Belli kurallara göre yazılan karakterler topluluğudur.

Tür (type): Değişken için bellekte ne kadar yer ayrılacağı ve içerisinde değerlerin hangi yönteme göre tutulacağını belirtir.

Faaliyet alanı (scope): Bir değişken isminin derleyici tarafından görülebildiği kod aralığıdır. Derleme zamanına işilkindir.

Ömür (storage duration): Bir değişkenin bellekte kalma süresidir. Çalışma zamanına ilişkindir.

Temel bazı kavramlar:
Blok (block): Bir metot içerisinde { ile } arasında kalan kod bölümüdür. Metodun gövdesi de bir bloktur.

İlkdeğer verme (initialization): Bir değişkene bildirim noktasında verieln değer denir. 

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bir metot içerisinde istenildiği kadar ayrı veya iç içe bloklar olabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		{
			//...
			
			{
				//..
			}
		}
		
		{
			//...
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Bir blok içerisinde herhangi bir yerde bildirilen değişkenlere yerel değişkenler (local variables) denir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		{
			//...
			
			{
				double b;
				int c;
				//..
			}
		}
		
		{
			float d;
			//...
		}
	}
}

class Sample{
	public static void foo()
	{
		int x;
		
		//..
		{
			//..
			boolean f;
			//..
		}
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı türden yerel değişkenler aralarında virgül konarak bildirilebilirler
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		double x, y, z;
	}
}

class Sample{
	public static void foo()
	{
		int x, y, z;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yerel değişkenlere ilkdeğer verme
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10; //ilk deger verme
		double pi = 3.14; //ilk degerveme sentaksı
	}
}

class Sample{
	public static void foo()
	{
		int x = 10, y = 30, z;
		
		z = 33;//initizlization değil.... 
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Yerel bir değikenin faaliyet alanı bildirildği yerden bildirilği bloğun sonuna kadardır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x;
			
			x = 20;
			
			//..
			
			{
				x = 45;
			}
		}
		
		x = 15; //error
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aynı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçersizdir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		int a;
		double a; //error
		//..
	}
	
	public static void bar() 
	{
		int a;
		
		{
			double a; //error
			//..
			
		}
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Farklı faaliyet alanı içerisinde aynı isimde yerel değişken bildirimi geçerlidir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class Sample{
	public static void foo()
	{
		{
			int x = 10;
			//..
		}
		
		{
			int x = 20;
			//..
		}
		
		int x = 30;
		
		//..
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değer verilmemiş hiçbir değiken kullanılamaz. Yani içerisindeki değer işleme sokulamaz
 * Yerel değişkenlere değer verilmesi programcının sorumluluğundadır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		int b;
		
		b = a * 2; //error
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * print ve println metotları değişkenlerin içerisindeki değerleri ekrana basarlar
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		
		System.out.print(a); //ekrana yazdırır
		System.out.println(a); //--> print("") sonrada alt satıra geçiririm 
		
	}
}

class Sample{
	public static void foo()
	{
	}	
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimleri sayısal bir karakter ile başlamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int 1number; //error
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri herhangi bir uygun karakter ile başlatılıp istenildği kadar sayısal karater içerebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a12345 = 10; 
		
		System.out.println(a12345);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede UNICODE alfabetik karakterler kullanabiliir. Örneğin türkçe karakter geçerlidir ,
 * 
 * Not: Her ne kadar değişken isimlendirmede UNICODE karakterler kullanılabildse de programlamada yalnızca
 * İngilizce alfabetik 26 karakterin kullanılması iyi bir tekniktir. Biz de bu "convention"' a uygun kodlar yazacağız.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int öğrencisayısı = 10; 
		
		System.out.println(öğrencisayısı);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimlendirmede boşluk (whitespace) karakterleri geçersizdir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int number Of Students = 10; 
		
		System.out.println(number Of Students);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Değişken isimleri büyük-küçük harf duyarlıdır (case-sensitive)
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int val, Val, VaL, VAL; //geçerli  
		
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Değişken isimlendirmede  _(underscore/ alttire) karakteri kullamabilir. Hatta değişken ismi _ karateri ile başalatılabilir.
 *
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int _11 = 20;
		int _val = 22;
		int number_of_students = 11;
		
		System.out.println(_11);
		System.out.println(_val);
		System.out.println(number_of_students);
		
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 9 ile birlikte alttire karaterinin tek başına değişken ismi olarak kullanıması geçersizdir. 
 * Java 8 ile birlikte "deprecated" olmuştur.
 * 
 * 
 * Not: Programlamda "artık kullanılması tavsiye edilmeyen" durumlar için "deprecated" terimi kullanılır.
 * Bu durum gerekçeleri farklı farklı olabilir. Programcı açısından genel olarak "deprecated" olan bir durum özel bir takım
 * nedenler yoksa tercih edilmemelidir.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int _ = 10; //error
		
		System.out.println(_);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java'da değişken isimlendirme $ karakteri kullanılabilir. Hatta isimler $ karakteri ile başlayabilir. $ karakteri
 * tek başına değişken ismi olabilir. Ancak programcı açısından değişken isimlendire $ karakteri kullanılmamalıdır.
 * Derleyici ismini kendisinin belirlediği durumlarda isimlendirmede bu karateri kullanır. $ karakteri bu anlamada
 * programcı tarafından kullanılırsa iism çakışması olabilir. Zaten $ karaterinin varlık sabebi de bu
 * tip kod üretimlerinde kulllanılmasıdır.
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		int amountOf$s = 1000;
		int $ = 35;
		double $123 = 123;
		
		System.out.println(amountOf$s);
		System.out.println($);
		System.out.println($123);
		
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Anahatar sözcükler tek başına değişken ismi olarak kullanılamaz. Ancak Java'ya daha sonra eklenmiş yerine göre
 * anahtar sözcük biçiminde kullanılan bazı atomlar vardır. Bu tarz eklenen sözcükler tam anlamıyla anahtar sözcük değildir.
 * Kullanıldığı yere göre değişken ismi olup olmadığı derleyici tarafından tespit edilir (inference, deduction). 
 * Bu tarz sözcüklere programlamada "bağlamsal anahtar sözcük (contextual keywords") de denir.
 
 
 	Not: Değişken isimlerinin kolay telaffuz edilebilir, anlamlı ve yeterince uzunlukta olması gerekir.
 	
 */

package orhn;

import java.nio.file.FileSystem;

public class App {
	public static void main(String [] args)
	{
		//int double; //error
		//double package; //error
		
		var a = 10;
		
		int var = 20;
		
		System.out.println(var);
		System.out.println(a);
						
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

06.12.2022 Salı


/*
 * Macar notasyonu
 * Camel case(lower camel case): numberOfCase
 * Pascal Case(upper camel case): SerialPort
 * snake case (unix style): number_of_students
 * 
 * 
 * Java coding style 
 * 
 */
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Klavyeden temel türden degerler okuma yöntemlerinin tam anlamı ileride detaylı olarak ele
 * alınacak. Bu sebeple bunları bir kalıp olarak görüp yalnıca kalyeden okuma kısmı ile ilgilenecez.
 * 
 * 
 * Klavyeden int türden değer okunması kalıbı
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Bir sayi giriniz:");
		int val = Integer.parseInt(kb.nextLine());
		
		int result = val * val;
		
		System.out.println(result);
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden int türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
 * Klaveyden double türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		double b = Double.parseDouble(kb.nextLine());
		
		
		double result = a * b;
		
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden long türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		long a = Long.parseLong(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		long b = Long.parseLong(kb.nextLine());
		
		
		long result = a * b;
		
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 
 * Klaveyden float türden deger okuma
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		float a = Float.parseFloat(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		float b = Float.parseFloat(kb.nextLine());
		
		
		float result = a * b;
		
		System.out.println(result);
		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar Konusu
 * 
 * ifade(expression): Sabitlerden, operatörlerden ve değişkenlerden oluşan herhangi bir dizilime ifade denir.
 * Değişkenler ve sabitler tek başına ifade belirtebilirken, operatorler tek başına ifade olamazlar. İstisna bir durum dışında
 * ifadeler hesaplandığında bir değer üretirler.
 * 
 *  a + b
 */

/*
 * Bir metodun geri dönüş degeri bilgisi yerine bir tür ismi yazılırsa bu metodun "geri dönüşü vardır" denir. 
 * Tersine bir metodun geri dönüş degeri varsa geri dönüş degeri bilgisi yerine bir tür ismi yazılır. 
 * Bir metodun geri dönüş deger varsa metot çağrısı bittikten sonra çağrıuldığı noktaya bir değer ile geri döner.
 * Bir metodun geri dönüş değeri yoksa geri dönüş değeri bilgisi yerine void anahtar sözcüğü yazılır. 
 * Bir metodun geri dönüş değeri metot içerisinde return  deyimi ile oluşturulur. 
 * 
 * return deyiminin genel biçimi:
 *  		return [ifade];
 *  
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Yani metot içerisinde akış return deyimine geldiğindemetot sonlanır 
 * ve akış çağrılan noktaya geri döner. return deyimine ilişkin ifadenin değeri çağıran metoda aktarılır.
 *  
 */


/*
 * Aşağıdaki örnekte add metodunun geri dönüş değeri 3 ile çarpılmış ve sonucu result değişkenine atanmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}






-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Not: Java derleyicisi genel olarak bir deyime akışın hiçber zaman gelemeyeceğini anlarsa o yazılan
 * deyim için error oluşturur (unreachable code).
 */

/*
 * return deyimi nasıl kullanılırsa kullanılsın metodu sonlandırır. Aşağıdaki örnekte return deyiminden sonra 
 * akış metot içerisinde kalmayacağından error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
		
		System.out.println("Unreachable Code");
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * akış return deyimine geldiğinde return deyimine ilişkin ifade önce hesaplanır, elde edilen değer döndürülür
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return result;		
	}
}





-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Geri dönüş değeri olan metotolarda (void olmayan metotlarda )return tek başına kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		return; //error		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Geri dönüş değeri olan metotolarda  akışın her noktasında bir değere geri dönemlidir. Aksi durumda error oluşur.
 * Aşaığıdaki örnekte result 10 değerinden küçük veya eşitise metot bir değer döndürmeyeceğinden error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3;
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		
		int result = a + b;
		
		if(result > 10)
			return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici geri dönüş değerinin çağıran metoda aktarımı geçici değişken yaratan bir kod üretir. 
 * Aşağıdaki ** ile belirtilen kod parçası için derleyicinin ürettiği temsili kod şu şekildedir:
 * 
 * 			int temp = a + b;
 * 
 * 			returlt = temp * 3;
 * 
 * Yani aslında geri dönüş değeri geçici değişkene yapılan bir atama işlemidir. Geçici değişkenin türü metodun
 * geri dönüş değerinin türü ile aynıdır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.add() * 3; //**
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		return a + b; // int temp = a + b;
		
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 *Geri dönüş değeri olan metotolar geri dönüş degeri işleme sokulmayacak şekilde çağrılabilirler. 
 *Şüphesiz metodun da tasarımı bu kullanım açısından anlamlı olmalıdır. Aşağıdaki örnekte add metotdu klavyeden alınan 
 *değerlerin toplamını ekrana basıp aynı zamanda da değere geri dönmektedir. Programcı kodda metodun sadece ekrana basmasıyla ilgilenmiş
 *ve geri dönüş değerini kullanmamıştır. Şephesiz başka bir çağrıda kullanaılabilir.
 *
 *
 *Metot ekrana toplam değerini basmasaydı bu şekilde çağırma uygun olurmu? (işimize yararmıydı)?
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		System.out.println(result);
		
		return result;
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Bir metodun geri dönüş değeri başka bir motdun geri dönüş değeri olarak verilebilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getAdd();
		
		System.out.println(result);
	}
}

class Util{
	public static int getAdd()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add();
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Aşağıdaki örnekte yine add metodunun geri dönüş değeri bir işleme sokulmuştur 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = Util.getResult();
		
		System.out.println(result);
	}
}

class Util{
	public static int getResult()
	{
		System.out.println("Toplama islemi yapılıyor");
		
		return NumberUtil.add() * 2;
	}
}

class NumberUtil{
	public static int add() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		return result;
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return deyimi zorunlu değildir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda return istenirse metodu sonlandırmak için tek başına kullanılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	void metotlarda return deyimi ifade ile kullanılamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		NumberUtil.printAdd();
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
		
		if(result < 0)
			return 10; //error
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	void metotlarda geri dönüş değeri varmış gibi çağrılamaz. Yani void metot çağrısı geri dönüş varmış gibi işleme sokulamaz
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int result;
		
		result = NumberUtil.printAdd(); //error
	}
}

class NumberUtil{
	public static void printAdd() //error
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		
		System.out.print("Birinci sayi giriniz:");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayi giriniz:");
		int b = Integer.parseInt(kb.nextLine());
		
		int result = a + b;
				
		System.out.println(result);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metot'larda parametre değişkenleri
 *
 * Metot bildirimlerinde metot isminden sonra parantezler arasında bildirilen değişkenlere "metot parametre değişkenleri"
 * ya da "parametre değişkneleri" denir. Bir metodun parametre değişkeni olmayabilir ya da istenildiği sayıda virgül ile 
 * ayrılarak bildirlebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a, int b)
	{
		//..
	}
	
	public static void printSquare(int a)
	{
		//..
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	bir metodun parametre değişkenleri aynı türden olsa bile tür bilgisi yazılmalıdır
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  b) //error
	{
		//..
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenleri faaliyet alanı bakımıından metot başında bildirilen yerel değişkenler gibidir.
 * Dikkat bu cümle sadece faaliyet alanı bakımından aynı oldujlarının söylüyor. Sonuçta yerel değişken ile 
 * parametre değişlkeni aynı değildir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Metodun parametre değişkenlerine değerler metot çağrılır iken verilir. Metot çağırlırken bir parametreye verilen
 * ifadeye "argüman" denir. Bir metot kaç tane parametre sahipse o kadar sayıda arguman ile çağrılmalıdır. 
 * Argumanlardan parametrelere aktarım da bir atam işlemidir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x, y);
		
		int result = NumberUtil.square(x);
		
		System.out.println(result);		
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b) //error
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metot parametre saysı kadar argüman ile çağrılmalıdır. Aksi durumda error oluşur.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x); //error
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	Metot çağrısında bir argüman ilişkin ifade önce hesaplanır, elde edilen değer ile metot çağrılır. Birden fazla
 *  parametreye sahip bir metot çağrısında tüm argümanlara ilişkin ifadeler hesaplanır, elde edilen değeler ile metot çağrılır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun parametre değişkeni ya da değişkenleri hem de degeri dönüş degeri olabilir.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		
		NumberUtil.printAdd(x + 3, y * 2);
			
	}
}

class NumberUtil{
	public static void printAdd(int a,  int b)
	{
		int result;
		
		result = a + b;
		
		System.out.println(result);
	}
	
	public static int square(int a) 
	{
		return a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.square(NumberUtil.add(x, y));

		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *	Bir metotdun geri dönüş değeri başka bir metoda argüman oalrak geçilebilir.
 *  Bu tip "compact" çözümler kodun okunabilirliğini / algılanabilirliğini etkilememelidir. Gerekirse ayrı ayrı hesaplanacak 
 *  şekilde yazılmalıdır.
 *
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.square(NumberUtil.add(x - 6, y - 5)));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *	bir önceki örnek okunabilirlik/algılanabilirlik açısından aşağıdaki gibi de yazılabilir
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int total = NumberUtil.add(x - 6, y - 5);
		int result = NumberUtil.square(total);
		
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		System.out.println(NumberUtil.add(x, y));
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(NumberUtil.add(x, y));
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşagıdaki  örnekte iki add çağrısı araında argumanlarda değişiklik olmamasına karşın programcı iki kere çağırmıştır.	
 * Bu duurumda kod hem iki defa çağırmanın gereksizliği hemde okunabilirlik/algılanabilirlik açısından kötü yazılmıştır.
 * 
 * 
 * kötü kod bu şekilde yazılması daha doğru
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Metotlar ne işe yarar= Ya da başka bir deyişle bir problemin çözümünde neden metotlar yazalım?
 * 
 * - Bir işi çok fazla yerde yapmak kod tekrarına yol açar. Yazılım geliştirmede temel prensip "zorunlu olmadıkça
 * 	 kod tekrarı yapılmamalıdır (do not repeat yourself)" şeklindedir. Bu durumda programcı örneğin bir metot yazar ve ilgili yerlerde bu metodu çağırır.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde  "implemente" edilmişse, bu durumda programcı
 *  problemin bir değişiklik yapmak isterse veya bir hata oldgunda anlayıp düzeltmek isterse her yerde bu değişilikleri yapmak zorunda kalacaktır. 
 *  Bu çoğu zman zor olabilir.
 * 
 * 
 * - Bir problemin çözümü metot çağırma yerine her yerde kodun yazılması biçiminde "implemente" edilmişse, bu durumda
 *   kodun okunabilirliği de azalabilir. Yani metot çağırarak kodun okunabilirliği de artmış olur.
 * 
 * - Metot yazıldıgında başka projelere taşınarak da kullanılabilir. (code re-usability)
 * 
 * - Metodu çağıran programcı metodun nasıl yazışdıgına ilişkin detayları bilmek zorunda değildir. Çünkü metodun
 *   çağrıldığı noktada metodun nasıl yazıldıgının önemi yoktur.
 *   
 *   
 *   Not: İleride ele alacağımız "nesne yönelimli programalama tekniği"'ne ilişkin kavramlar ile kodun parçalara ayrılması metotlar
 *   dışında daha yüksek seviyede de yapılabilmektedir. Yani kabaca bu tarz programlamanın temelinde metotlar vardır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int x = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayıyı giriniz : ");
		int y = Integer.parseInt(kb.nextLine());
		
		int result = NumberUtil.add(x, y);
		
		System.out.println(result);
		
		//.. x ve y ile değişiklik yapmıyorum
				
		System.out.println(result);
	}
}

class NumberUtil{
	public static int add(int a,  int b)
	{	
		return a + b;	
	}
	
	public static int square(int a) 
	{
		return a * a;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * System.out.printf metodunun ilk argümanı String olmalıdır. Metot bu argüman dışında istenilen sayıda ve istenilen türde
 * argüman ile çağıralabilir. Metodun birinci parametresine ilişkin argümanda % karateri ile birlikte geçerli
 * bazı karakterler kullanıldıgında "yer tutucu (place holder)" belirtişmiş olur. % ile birlikte kullanıma
 * "format belirleyici (format specifiers)" da denir. % birlikte kullanılan geçerli karatere ise "format karateri" denir.
 * Metot yer tutucular yerine diğer geçilen argümanlara ilişkin degerleri yerleştirir ve ekrana bu yazıyı basar. 
 * Bazı format karaterleri bir argümana ilişkin değere karşılık gelmez. Özel anlamları vardır.
 * 
 * 
 * Not: printf gibi değişkeb sayıda argüman alabilen metotlara "variadic methods" denir. 
 * Buarada bu tarz metotların nasıl yazıldıgı ele alınmayacaktır.
 * 
 */


/*
 * Tamsayı türlerinin (short, int, long, byte) decimal olarak formatlanması  d format karateri kullanılır.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayıyı giriniz : ");
		int degree = Integer.parseInt(kb.nextLine());
		
		System.out.printf("Bugün hava %d derece", degree);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda imleci bir sonraki starın başına geçirmek için %n kullanılabilir. %n bu anlamda bir argümana karşılık gelmez
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Arasınav notunuzu giriniz : ");
		int midtermGrade = Integer.parseInt(kb.nextLine());
		
		System.out.print("Final notunuzu giriniz : ");
		int finalGrade = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("Arasınav : %d%nFinal: %d%n", midtermGrade, finalGrade);
		System.out.println("Geçme notrunuz hesaplanıyor!....");
		//...
		//..
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodu x, X, h, H format karaterleri ile tamsayi türlerine ilişkin değerler hexadecimal olarak formatlanabilir.
 * Ayrıca o format karateri ile tamsayı türlerine ilişkin değerler octal olarak formatlanabilir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %x%n", val);
		System.out.printf("val = %X%n", val);
		System.out.printf("val = %h%n", val);
		System.out.printf("val = %H%n", val);
		System.out.printf("val = %o%n", val);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %-8d  %10d%n", val, val);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir. Aşağıdaki örnekte  %08X yer tutucu için 
 * yazıulan karater sayısı 8'den kucukse geri kalanlar için sıfır yazılır 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Bir sayi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("val = %d%n", val);
		System.out.printf("val = %8d%n", val);
		System.out.printf("val = %-8d  %8d%n", val, val);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%02d/%02d/%04d%n", day, mon, year);

	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda tamsayılar için hizalam yapılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Gün : ");
		int day = Integer.parseInt(kb.nextLine());
		System.out.print("Ay : ");
		int mon = Integer.parseInt(kb.nextLine());
		System.out.print("Yıl : ");
		int year = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%2d/%02d/%4d%n", day, mon, year);

	}
}



-----------------------------------------------------------
-----------------------------------------------------------
08/12/2022

/*
 * printf metodunda gerçek sayılar (folat ve double) için f format karateri kullanılabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %f%n", dval);

	}
}




-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda  f format karateri ile ondalık kısmın kaç basamak olarak formatlanacağı 
 * aşagıdaki gibi belirtilebilir.
 * Geri kalan basmaklar bilimsel olarak yuvarlanır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("bir gercek sayi giriniz : ");
		double dval = Double.parseDouble(kb.nextLine());
		
		System.out.printf("val = %.3f%n", dval);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  char türü için c format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 3333;
		
		System.out.printf("c = %c%n", c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  boolean türü için b format karateri kullanilabilir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %b%n", flag);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda  uygun format karakterlei kullanılmadıgında genel olarak exception oluşur.
 * 
 * Bu durumun istisnaları var
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		boolean flag = true;
		
		System.out.printf("flag = %d%n", flag);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda s format karateri ile tür ne olursa olsun formatlanabilir. Şüphesiz bu durumda türe özgü
 * biçimler (hizalama vs) kullanılmaz. Bu format karakterinin ayrıntıları ileri ele alınacak
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		double b = 3.4;
		boolean c = true;
		char d = 67;
		
		System.out.printf("a = %s, b = %s, c = %s d= %s%n", a, b, c, d);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * printf metodunda % karakterinden sonra uygun bir format karateri getirilmelidir
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %  %f%n", ratio);
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * printf metodunda % karakteri için iki tane % karateri kullanılmalıdır
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		double ratio;
		
		ratio = 18.4;
		
		//  % 18.4
		
		System.out.printf("Oran : %%%f%n", ratio);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
Not: printf metodunun format karakterleri ve kullanım biçimleri oldukça geniştir. 
Burada sadece temel olanlar ele alınmıştır. Diğer format karakterleri ve kullanım biçimleri konular içerisinde ele alınacaktır.
-----------------------------------------------------------
-----------------------------------------------------------

Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
	
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 
Çalışma: Klavyeden girilen iki tane int türden sayının toplamını ve çarpımını aşagıdaki gibi
ekrana basan programı yazınız:

Girelen sayılar 10 ve 20 ise

	10 + 20 = 30
	10 * 20 = 200
	
	şeklinde çıktılar verecektir.
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		FindSumMultiplyApp.run();
	}
}

class FindSumMultiplyApp{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d + %d = %d%n", a, b, NumberUtil.add(a, b));
		System.out.printf("%d * %d = %d%n", a, b, NumberUtil.multiply(a, b));
		
	}
}

class NumberUtil{
	public static int add(int a, int b)
	{
		return a + b;
	}
	
	public static int multiply(int a, int b)
	{
		return a * b;
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Bölme işlemi tamsayılar ile yapıldıgında sonuç her zaman tamsayı çıkar. Elde edilen sayının noktadan sonraki kısmı
 * yuvarlanmadan atılır.
 * 
 * Tamsayılar ile bölme işleminde paydanın sıfır olması durumnda exception olusur
 * 
 * .Bu durumların detayları ileri ele alınacak
 * 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		double result = a / b;
		
		System.out.printf("%d  / %d = %f%n", a, b, result);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * format metot du ile printf tamamen aynı işlemi yapar
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		int a = Integer.parseInt(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.format("%d  %d %n", a, b);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * 	Gerçek sayılar ile bölme işleminde payda sıfır olsa da işlem yapılır. Yani bir exception oluşmaz. Gerçek sayılar
	içerisinde genel olarak Matematik'teki "belirsizlik" için kullanılan "Not a number (NaN)" değeri vardır. Ayrıca
	genel olarak sonsuzluk (Matematik'teki tanımsızlık) için kullanılan -Infinity ve +Infinity değerleri de vardır. 
	Bu özel değerler dışında da başka özel değerler vardır. Bu durumda gerçek sayılar ile bölme işleminde pay sıfırdan
	farklı, payda sıfır ise payın işaretine göre + veya - Infinity, pay ve paydanın ikisi birden sıfır ise NaN sonucu
	elde edilir 
 * 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		System.out.print("İkiinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
		
		double result = a / b;
		
		System.out.printf("%f / %f = %f%n", a, b, result);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * 	Neden standart metoları kullanmalıyız? Yani standart olarak var olan metodu programcı yazmalımıdır?
 * 	Java da standart olarak (JavaSE) bulunan metotların kullnılmasının bazı önemli avantajları varıdr:
 * 
 * 	-okunabilir kodlar yazılır
 *  -Testleri yapılmıştır ve yeterince etkin olarak yazılmıstır
 *  -Taşınabilir
 *  -Bazı metotlar (ki bunların sayısı oldukca fazladır) baska detay konularıda bilmeyi gerektirir
 *  -Programcının projede sadece kendi konusna odaklanmasıı saglar
 *  
 *   Bu durumda bir Java programcısı çözmesi gereken bir problem için JavaSE'de problemin çözümüne ilişkin metotlar varsa
 *	 onları kullanmalıdır. Yoksa yazma işlemine girişmelidir. Ancak bu druum programcının standart kullandığı metotların
 *	 nasıl yazıldığını gözardı etmesi anlamına gelmez. Programcı programlama yaşamı boyunca hepsini olmasa da hazır olarak
 *	 kullandıklarının nasıl gerçekleştirilebileceğini öğrenmelidir
 */

/*
 * Math sınıfı abs metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("|%f| = %f%n", a, Math.abs(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı sqrt metodu: Metot negatif degerler için NaN degerine geri döner
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
	
		System.out.printf("sqrt(%f) = %f%n", a, Math.sqrt(a));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfı pow metodu
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi girin: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("Birinci sayiyi girin: ");
		double b = Double.parseDouble(kb.nextLine());
	
		System.out.printf("pow(%f, %f) = %.12f%n", a, b, Math.pow(a, b));
		
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}
	
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Çalışma: Parametresi ile aldıgı double tür x1, y1, x2, y2 koordinat bilgileribe göre
 * iki nokta arasındaki ((x1, y1) ve (x2, y2) noktaları) uzaklıga geri dönen distance isimli metodu PointUtil isimli
 * sınıf içerisinde yazınız.
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		DistanceTest.run();
	}
}

class DistanceTest{
	public static void run()
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("x1: ");
		double x1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y1: ");
		double y1 = Double.parseDouble(kb.nextLine());
		
		System.out.print("x2: ");
		double x2 = Double.parseDouble(kb.nextLine());
		
		System.out.print("y2: ");
		double y2 = Double.parseDouble(kb.nextLine());
	
		System.out.printf("Destance: %f%n", PointUtil.distance(x1, y1, x2, y2));
	}
}

class PointUtil
{
	public static double distance(double x1, double y1, double x2, double y2)
	{
		double dx = x1 - x2;
		double dy = y1 - y2;
		
		return Math.sqrt(dx * dx + dy * dy);
	}
	
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfın PI ve E elemanları
 *  
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println(Math.PI);
		System.out.println(Math.E);
		
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının trigonometrik işlem yapan metotları radyan ölçü birimi ile çalışır
 * 
 * Radyan ve derece arasındaki dönüşümler için toRadians ve toDegrees metotoları kullanılabilir. 
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("value: ");
		double value = Double.parseDouble(kb.nextLine());
		
		System.out.printf("sin(%f) = %f%n", value, Math.sin(Math.toRadians(value)));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f) = %f%n",a ,b ,Math.min(a, b));
		System.out.printf("max(%f, %f) = %f%n",a ,b ,Math.max(a, b));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, Math.min(Math.min(a, b), c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, Math.max(Math.max(a, b), c));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının min ve max metotları metotları ile 3 tane sayının en kucuk v e en buyuk olanını bulma
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.print("c: ");
		double c = Double.parseDouble(kb.nextLine());
		
		System.out.printf("min(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.min(a, b, c));
		System.out.printf("max(%f, %f, %f) = %f%n",a ,b ,c, MathUtil.max(a, b, c));
	}
}

class MathUtil{
	public static double min(double a, double b, double c)
	{
		return Math.min(Math.min(a, b), c);
	}
	
	public static double max(double a, double b, double c)
	{
		return Math.max(Math.max(a, b), c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f) = %f%n", a, Math.log(a));
		System.out.printf("log10(%f) = %f%n", a, Math.log10(a));
		System.out.printf("log1p(%f) = %f%n", a, Math.log1p(a));
	}
}



-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		
		System.out.print("b: ");
		double b = Double.parseDouble(kb.nextLine());
		
		System.out.printf("log(%f, %f) = %f%n", a, b, MathUtil.log(a, b));
	}
}


class MathUtil{
	public static double log(double a, double b) {
		return Math.log10(b) / Math.log10(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Math sınıfının logXXX metotları
 */

package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("a: ");
		double a = Double.parseDouble(kb.nextLine());
		
		System.out.printf("round(%f) = %d%n", a, Math.round(a));
		System.out.printf("ceil(%f) = %.20f%n", a, Math.ceil(a));
		System.out.printf("floor(%f) = %.20f%n", a, Math.floor(a));
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*----------------------------------------------------------------------------------------------------------------------,
	Sabitler (literals, constants)
	Program içerisinde doğrudan yazılan sayılara denir. Sabitlerin de türleri vardır. Derleyici sabitlerin türlerini 
	tespit ederek işlem yapar.
	
	Sabitlerin türlerinin tespitine ilişkin detaylar:
	- Sayı nokta içermiyorsa, sonuna bir ek almamışsa ve int türü sınırları içerisindeyse int türdendir. Sayı int türü
	sınırları içerisinde değilse error oluşur. 
	Örneğin: 100, 2000, 2000000000
	
	- Sayı nokta içermiyorsa ve sonuna L (küçük veya büyük) ekini almışsa long türdendir. Sayı long türü sınırları
	dışındaysa error oluşur. 
	Örneğin: 10L, 4000000000L
	
	Anahtar Notlar: Küçk harf L kullanımı 1(bir) rakamanına benzemesinden dolayı programlamada tercih edilmez. 
	
	- Java'da byte ve short türden sabitler yoktur
	
	- Sayı nokta içeriyorsa ve sonuna bir ek almamışsa double türdendir. Sayı double olarak ifade edilemiyor ise
	error oluşur
	Örneğin: 3.4, 6.7
	
	- Sayı nokta içersin ya da içermesin sonunda D (küçük ya da büyük) eki varsa double türdendir.
	Örneğin: 3D, 10d, 30.56D
	
	- Sayı nokta içersin ya da içermesin sonunda F (küçük ya da büyük) eki varsa float türdendir.
	Örneğin: 3F, 2f, 3.4F
	
	- boolean türden iki tane sabit vardır: true, false
	
	- char türden sabitler: İki tane tek tırnak karakteri arasında yazılan bir karakter, karakter tablosunda sıra 
	numarası belirtir. Bu şekilde yazılan sabitlere "karakter sabitleri (character literals)" denir ve bu sabitler char
	türdendir. İki tane tek tırnak karakteri arasında özel durumlar dışında birden fazla karakter yazımı geçersizdir. 
	
	Bazı karakterlerin klavyeden basılması doğrudan derleyici tarafından karakter olarak algılanamaz. Hatta bazı
	karakteler "non-printable"'dır. Örneğin bir sonraki satıra geçme karkaterinin karakter sabiti doğrudan yazılamaz.
	Bu tip bazı karakterler klavyeden doğrudan yazılamazlar. Bu tarz karakterlerin karakter sabitleri iki tane tek
	tırnak içerisinde ters bölü karakteri ile onu takip eden özel bir karakter biçiminde yazılır. Bu şekilde yazılan
	karakterlere "escape sequence" karakterler denir. Hatta bazı karakterler hem normal hem de ters bölü ile yazılabilirler:
	Java'da desteklenen escape sequence karakterler şunlardır:
	
	'\n' -> line feed (LF) 
	'\r' -> carriage return (CR)
	'\t' -> horizontal tab
	'\b' -> backspace
	'\f' -> form feed
	'\0' -> null karakter
	'\"' -> double quote (optional)
	'\'' -> single quote
	'\\' -> back slash  
----------------------------------------------------------------------------------------------------------------------*/

/*
 * char türden sabitler
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'D';
		
		System.out.println(c);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * iki tane tek tırnak arasında birden fazla karater yazımı özel durumlar dışında geçersizdir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = 'De'; //error
		
		System.out.println(c);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Line feed karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\n';
		
		System.out.printf("Marhaba");
		System.out.print(c);
		System.out.printf("Nasılsın ");
		System.out.printf("Ali");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Carriage return karater sabiti: 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\r';
		
		System.out.printf("Marhabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Horizontal tab karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\t';
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.print(c);
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Backspace karater sabiti
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char c = '\b'; 	
		
		System.out.printf("Merhaba");
		System.out.print(c);
		System.out.printf("Nasilsin ");
		System.out.printf("Ali");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\nNasılsın\nİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Merhaba,\rİyi misin?");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Escape sequence karaterler "String Literal" içerisinde kendi anlamındadır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch1 = '"';
		char ch2 = '\"';
		
		System.out.println(ch1);
		System.out.println(ch2);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * İki tırnak karateri string atomu içerisinde ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\"Merhaba Ali, nasıl gidiyor\"");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Tek  tırnak karateri string atomu içerisinde dogrudan ya da ters bölü ile kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("'Merhaba Ali, nasıl gidiyor\'");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
13.12.2022 Salı


/*
 * Tek  tırnak karater sabiti ters bölü ile yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\'';
		
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Escape karakterlerinden dolayı istenilen sonuç elde edilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *yukarıdaki problem aşağıdaki gibi çözümlenir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\\testdata\\noname.txt");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *ters bölü karakterinden sonra özel karakterler dışında yazılan karakter error olusturur
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("C:\testdata\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------

/*
 *\\\\192.168.1.21\\testdata\\orhan.txt yol ifadesi "String literal" içerisinde yazılması gerek
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("\\\\192.168.1.21\\testdata\\orhan.txt");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  tek tırnak karakteri değildir -- backtick
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '`';
				
		System.out.println(ch);
		System.out.println("`Orhan OZTURK`");
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü ve u karakteri ile bir karakterin sıra numarası hexadecimal olarak tek tırnak içerisinde yazıldıgında
 *  o karatere ilişkin karater sabiti yazılmış olur. Burada hexadecimal sayı kesinlikle iki byte olarak yani
 *  4 tane hex digit olarak yazılmalıdır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		char ch = '\u00CB';
				
		System.out.println(ch);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter sabitleri "string literal" atomu içerisinde de kullanılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		System.out.println("Orhan OZTURK : \u1788");
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Ters bölü u ile yazılan karakter değişken isimlendirmede de kullanılabilir. Şüphesiz pratik değildir.
 *  
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int \u0041\u0042\u00CB = 10;

		System.out.println(AB\u00CB);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  bir tamsayının ön eki yoksa bu durumda sabit "decimal" olarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik ıkarak sıfır ve x (buyuk ve kucuk farketmez) yazıldıgında ekten sonra gelen 
 *  basamaklar  "hexadecimal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0xA;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik sıfır yazıldıgında ekten sonra gelen 
 *  basamaklar  "octal" oalarak ele alınır
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 012;

		System.out.println(a);
	}
}


-----------------------------------------------------------
-----------------------------------------------------------


/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 0b1010;

		System.out.println(a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  Bir tamsayı sabitinin önüne bitişik 0b yazıldıgında ekten sonra gelen basamaklar  "binary" oalarak ele alınır.
 *  ikilik sistemde yazulan sabitler Java 7 ile eklendi.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Aşağıdaki örnekte SensorUtil sınıfının out metodu 16 tane pini olan bir elektronik devre için aldığı argüman 
	değerine göre değerin bit'lerin karşılık gelen pinleri 1 ya da sıfır için "high" ya da "low" seviyeye çekiyor olsun.
	Bu durumda böyle bir metodun alacağı sabit argümanın "binary" veya "hexadecimal" olarak yazılması okunabilirliliği
	artırır. Ayrıca yazım kolaylığı da sağlar. Aşağıdaki demo örneği yukarıdaki senaryoya göre düşününüz   
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		short value = 0b11101;
		
		SensorUtil.out(value);
		
		value = 0x1D;
		
		SensorUtil.out(value);
	}
}

class SensorUtil{
	public static void out(short value)
	{
		System.out.printf("value:%04X%n", value);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a = 1.3E10;
		double b = 1.3e10;
		double c = 1.3E+10;
		double d = 1.3e+10;
		double e = 1.3E-10;
		double f = 1.3e-10;
		
		
		System.out.printf("a  = %f%n", a);
		System.out.printf("b  = %f%n", b);
		System.out.printf("c  = %f%n", c);
		System.out.printf("d  = %f%n", d);
		System.out.printf("e  = %.12f%n", e);
		System.out.printf("f  = %.12f%n", f);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gercekı sayıların üstel (bilimsel) gosterilişi
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double avogadroConstant = 6.02E23;
		
		System.out.println(avogadroConstant);
		System.out.printf("%f%n", avogadroConstant);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0xFC_AB_CD;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Java 7 ile birlikte tamsayı ve gerçek sayı sabitleri içerisinde alttire karaterleri kullanılabilmektedir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_456_123_000L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 5_______________________________________8L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri kullnaıldıgı yerde istenildigi kadar yazılabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a;
		
		a = 0b10101010_10101011_10101010_0011L;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("a = %X%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = _67; //error
		b = 43_; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sayı nokta içerisiyorsa noktadan hemen önce veya sonra alttire geçilemez
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 6_.4; //error
		b = 4._4; //error
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 *  alttire karateri sabitin sonunda ve başında olamaz sentaks hatası
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long a, b;
		
		a = 5000000000L_; //error
		b = 5000000000_L; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * alttire karateri sabit önündeki eklerdeb önce sonra yada ekler arasına konulamaz
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b, c;
		
		a = 0x_AB; //error
		b = _0xAB; //error
		c = 0_xAB; //error
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * alttire karateri octal sabitler için önek ile (sıfır ile) ilk basamak arasında geçerlidir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 0_12;
		
		System.out.println(a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Gerçek sayı sabitlerinin tamsayı kısmının degeri sıfır ise noktadan nce sıfır yazılmayabilir.
 * Benze şekilde sayının noktadan sonraki kısmının tamamı sıfır ise yibe sıfır noktadan sonra yazılmayabilir
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		double a, b;
		
		a = .3;
		b= 3.;
		
		System.out.printf("a = %f%n", a);
		System.out.printf("b = %f%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Yalnızca sabitlerden ve operatörleden oluşan yani içerisinde değişken olmayan ifadelere "sabit ifadesi (constant expression)" denir.
 * Buy anlamda sabit de tek başına bir sabit ifadesidir.
 * 
 * 
 * Not: İleride aslında sabit ifadesi olark kullanılabilen değişkenler de göreceğiz. Bu tarz değişknler de
 * bir ifade içersinde sabit olarak ele alınır.
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		b = 20;
		
		System.out.println(NumberUtil.add(a - 2, b)); //argümanların hiçbiti sabit ifadesi değil
		System.out.println(NumberUtil.add(10 + 5, 89 - 8)); //argümanların hepsi sabit ifadesi 
	}
}

class NumberUtil{
	public static int add(int a, int b) {
		return a + b;
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Derleyiciler sabit ifadelerinin değerlini hesaplayarak sonucu "byte code" a yazarlar. Bu optimizasyona
 * "constant folding optimizasyonu" denir. Bu sebeple aşağıdaki kodda 1000L * 60 * 60 * 24 * 365 ifadesinin
 * değeri byte code'a 31536000000 şeklinde yazılır. Aşağıdaki örnekte bilgi kaybı olmaması için 1000 sabitini 
 * long olarka yazılmıstır. Konuya ileride değinecez.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		long divider = 1000L * 60 * 60 * 24 * 365; //byte code --> long divider = 31536000000;
		
		System.out.println(divider);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
			Operatörler
			
	Operatörler: Bir işleme yol açan ve işlem sonucunda bir değer üreten atomlara operatör denir. Operatör ile
	birlikte işleme giren ifadelere "operand" denir.
	
	Operatörleri 3(üç) biçimde sınıflandırılabilir:
	1. İşlevlerine göre sınıflandırma
		- Aritmetik (arithmetic) operatörler
		- Karşılaştırma (comparison) operatörleri
		- Mantıksal (logical) operatörler
		- Bitsel (bitwise) operatörler
		- Özel amaçlı (special purpose) operatörler	
	2. Operand sayısına göre sınıflandırma
		- Tek operandlı (unary)
		- İki operandlı (binary)
		- Üç operandlı (ternary)	
	3. Operatörün konumuna göre sınıflandırma
		- önek (prefix)
		- araek (infix)
		- sonek (postfix)
		
	Operatörün kısıtı (constraint)
	Operatörün ürettiği değer (product value)
	Operatörün yan etkisi (side effect) var mı?
	Operatörün önceliği (precedence):
	
	a = b + c * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: c * d
	i2: b + i1
	i3: a = i2
	
	a = (b + c) * d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 * d
	i3: a = i2	
	
	a = b + c - d ifadesinin derleyici tarafından üretilen kodda yapılma sırası
	
	i1: b + c
	i2: i1 - d
	i3: a = i2
		
	Not: Java programcısı bir operatör için yukarıdaki durumları bilmelidir. Yani bir operatörün öğrenilmesi
	o operatör için yukarıdaki durumların bilinmesi anlamına gelir.	
	
	Not: Bazı operatörler öncelik kuralına doğrudan uymazlar. Bu tarz operatörlerin de uymadıkları durum için
	nasıl çalıştıklarının bilinmesi gerekir. Şüphesiz bu operatörlerin neden öncelik kurallarına uymadıklarının da 
	gerekçeleri (rationale) bulunur.
	
	
	Not: Operatör öncelik tablosu gruplandırma olarak düşünülebilir. Yani operatör öncelik tablosundaki öncelik
	durumlarının yapılış biçimine ilişkin istisnaları olabilir. Şüphesiz bunun da bilinmesi gerekir. Operatör öncelik
	tablosu algısal bakımdan kolaylaştırmak için vardır ve önemlidir.	

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Artimetik 4 işlem ve mod operatörleri iki operandlı (binary) ve araek (infix) operatörlerdir.
 * Bu operatörlerin ürettileri değer işlemin sonucunda elde edilen değerdir. 
 * Bu operatörlerin yan etkisi (side effect) yoktur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		
		System.out.printf("%d + %d = %d%n", a, b, a + b);
		System.out.printf("%d - %d = %d%n", a, b, a - b);
		System.out.printf("%d * %d = %d%n", a, b, a * b);
		System.out.printf("%d / %d = %d%n", a, b, a / b);
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------
/*
 * Mod operatörünün birinci operandı negatif ise sonuç negatif çıkar. İkinci operandının negatif olmasının bir önemi yoktur.
 * Başka bir deyile mod operatörünün sonucunun işareti birinci operandının işareti ile aynıdıur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		System.out.print("İkinci sayiyi giriniz : ");
		int b = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d %% %d = %d%n", a, b, a % b);
		
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Çalışma: Parametresi ile aldığı en fazla 3 basamaklı int türünden bir sayının basamakları toplamına
 * geri dönen digitsSum isimli metodu NumberUtil sınıfı içerisinde yazınız. Metot aldıgı argümanın en fazla
 * 3 basamaklı olup olmadıgını kontrol etmeyecektir. Basamaklar toplamı pozitif olarak döndürecektir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		DigitsSumTest.run();
	}
}

class DigitsSumTest{
	public static void run() {
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int val = Integer.parseInt(kb.nextLine());
		
		System.out.printf("%d sayısının basamakları toplamı = %d%n", val, NumberUtil.digitsSum(val));
	}
}

class NumberUtil{
	public static int digitsSum(int val) {
		int a, b, c;
		
		a = val / 100;
		b = val / 10 % 10;
		c = val % 10;
		
		return Math.abs(a + b + c);
	}
	
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerinin tersini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = -a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * işaret + aritmetik operatörü tek operandlı (unary) ve önek (prefix) durumunda bir operatördür. 
 * Operatörünün yan etkisi yoktur.
 * Operaötr operandına ilişkin ifadenin degerini üretir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		
		int b;
		
		b = +a;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * işaret - operaörünün seviyesinde bulunan operaötlerin sagdan sole (right associative)
 * ele alınmasından dolayı geçerlidir.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		java.util.Scanner kb = new java.util.Scanner(System.in);
		System.out.print("Birinci sayiyi giriniz : ");
		int a = Integer.parseInt(kb.nextLine());
		int b;
		
		b = a - - - - - - - - - - 2;
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * geçerli ifade
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a =  - - - - - - - - - - 10;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		++a; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}

-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 artırır.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = 10;
		
		a++; // a = a + 1;
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü prefix kullanımında ürettiği deger yani işleme giren deger arttırılmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = ++a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ++ operatörü postfix kullanımında ürettiği deger yani işleme giren deger arttırılMAmıs degerdir
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a++; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		--a; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * -- operatörü tek operandlı ve hem prefix hemde postfix olarak kullanılabilen bir operatördür.
 * 
 * bu operatör prefix ya da postfix her iksi içinde operandına ilişkin değişkenin degeri 1 azaltma.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		a--; // a = a - 1; 
		
		System.out.printf("a = %d%n", a);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü prefix kullanılmaktadır degeri o an azaltmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = --a; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * -- operatörü postfix kullanılmaktadır degeri o an azaltMAmıstır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a--; 
		
		System.out.printf("a = %d%n", a);
		System.out.printf("b = %d%n", b);
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + ++a; 
		
		System.out.printf("a = %d%n", a); // 10
		System.out.printf("b = %d%n", b); //21 //22 //20
	}
}
-----------------------------------------------------------
-----------------------------------------------------------
/*
 * ekrana ne bastırır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 3;
		
		b = a-- + ++a * a; //3 + 3 * 3 = 12
		
		System.out.printf("a = %d%n", a); // 3
		System.out.printf("b = %d%n", b); //12
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ekrana ne bastırır
 * Aşağıdaki örnekte ++ ve -- operatörleri ve operandları aynı ifadede kullanılmıştır
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a, b;
		
		a = 10;
		
		b = a-- + a-- + a; //10 + 9 + 8
		
		System.out.printf("a = %d%n", a); // 8
		System.out.printf("b = %d%n", b); //27
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * Derleyici yukarıdan aşağıya ve soldan sağa olmak üzere anlamlı en uzun ifadeyi
 * alacak şeklilde atomlarına ayırma işlemi yaparak (maximum munch). 
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a = 10;
		int b = 11;
		int c;
		
		c = a+++b; //a++ + b 
		
		System.out.printf("a = %d%n", a); 
		System.out.printf("b = %d%n", b); 
		System.out.printf("c = %d%n", c); 
	}
}

	Not: Okunabilirlik/algılanabilirlik açısından tek operandlı operatörleri genel olarak operandına
	bitişik biçimde yazacağız. İki operandlı operatörleri de özel ama önemli operatörler dışında operandları ile operatör
	arasında yalnızca bir tane "space" karakteri olacak şekilde yazacağız
	
-----------------------------------------------------------
-----------------------------------------------------------

/*
 * ++ ve -- operatörlerinin operandlarının değişken olması gerekir. Aksi durumda error oluşur.
 * 
 */
package orhn;

public class App {
	public static void main(String [] args)
	{
		int a;
		
		a = --2;//error
		
		
	}
}
-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------



-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------



-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------



-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------



-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------



-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------



-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------

-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------


-----------------------------------------------------------
-----------------------------------------------------------





